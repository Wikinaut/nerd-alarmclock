#!/usr/bin/python
# --------------------------------------------------------------------------
# Class definition of AlarmController - manage alarms.
#
# Author: Bernhard Bablok
# License: GPL3
#
# Website: https://github.com/bablokb/nerd-alarmclock
#
# --------------------------------------------------------------------------

import datetime, time, threading

# --- value holder class for alarms   --------------------------------------

class Alarm(object):
  """ Value holder for alarms """

  # --- constructor (read settings)   --------------------------------------
  
  def __init__(self,settings,nr):
    """ Constructor """
    self.nr     = nr
    self.state  = settings.get("alarm."+nr+".state")
    self.time   = settings.get("alarm."+nr+".time")
    self.snooze = settings.get("alarm."+nr+".snooze")
    self.days   = settings.get("alarm."+nr+".days")
    self.event  = None

  # --- initialize pending-state of alarm   --------------------------------
  
  def init_pending(self,now=None,weekday=None):
    """ set pending-state of alarm """

    if not now:
      now = time.strftime("%H:%M")
    if not weekday:
      weekday = int(time.strftime("%u"))

    self.pending = ( self.state == "enabled" and
                     self.time > now and
                     weekday in self.days )

# --- AlarmController class   ----------------------------------------------

class AlarmController(object):
  """ AlarmController """

  # constants   ------------------------------------------------------------

  POLL_INTERVAL  = 1

  # initialize object   ----------------------------------------------------

  def __init__(self,settings):
    """ Constructor """

    self._settings   = settings
    self._stop_event = settings.stop_event
    self._init_alarms()

    # we need to register for changes in date and time
    self._settings.add_settings_listener('_current_date',self.on_date)
    self._settings.add_settings_listener('_current_time',self.on_time)

    # register for alarm-time and alarm-state changes
    for i in range(settings.MAX_ALARMS):
      self._settings.add_settings_listener('alarm.%d.time' % (i+1),
                                           self.on_alarm_time)
      self._settings.add_settings_listener('alarm.%d.state' % (i+1),
                                           self.on_alarm_state)
    # register for snooze-events
    self._settings.add_settings_listener('_snooze',self.on_snooze)

  # --- initialize alarms   ------------------------------------------------

  def _init_alarms(self):
    """ Initialize alarms """

    now = time.strftime("%H:%M")
    # initialize map of alarms
    self._alarms = {}
    weekday = int(time.strftime("%u"))
    for i in range(self._settings.MAX_ALARMS):
      nr    = str(i+1)
      alarm = Alarm(self._settings,nr)
      alarm.init_pending(now,weekday)
      self._settings.log.msg("AlarmController: alarm[%s].time: %s" % (nr,alarm.time))
      self._settings.log.msg("AlarmController: alarm[%s].pend: %r" % (nr,alarm.pending))
      self._alarms[nr] = alarm

  # --- update alarm-timers if time changes   ----------------------------

  def on_alarm_time(self,name,old,new):
    """ Update alarms on alarm-time change"""

    nr = name[6]
    self._settings.log.msg("AlarmController: updating alarm-time for alarm %s" % nr)
    alarm = self._alarms[nr]
    alarm.time = new
    alarm.init_pending()
    self._settings.log.msg("AlarmController: alarm[%s].time: %s" % (nr,alarm.time))
    self._settings.log.msg("AlarmController: alarm[%s].pend: %r" % (nr,alarm.pending))

  # --- update alarm-timers if state changes   ----------------------------

  def on_alarm_state(self,name,old,new):
    """ Update alarms on state-change """

    nr = name[6]
    self._settings.log.msg("AlarmController: updating alarm-state for alarm %s from %s to %s" %
                           (nr,old,new))

    # update data-structures
    alarm = self._alarms[nr]
    alarm.state = new
    alarm.init_pending()
    self._settings.log.msg("AlarmController: alarm[%s].time: %s" % (nr,alarm.time))
    self._settings.log.msg("AlarmController: alarm[%s].pend: %r" % (nr,alarm.pending))

    # stop alarm-thread if necessary
    if old == "ringing" and new == "enabled" and alarm.event:
      self._settings.log.msg("AlarmController: stopping alarm %s" % nr)
      alarm.event.set()

  # --- snooze-state listener   --------------------------------------------

  def on_snooze(self,name,old,new):
    """ process snooze-state changes """

    self._settings.log.msg("AlarmController: on_snooze %r" % new)
    if not new:
      # ignore _snooze=False
      return

    nr = self._settings.get("_current_alarm")
    # stop current alarm
    if nr[0] == "-":
      # snoozing a snooze-alarm
      self._alarms[nr].event.set()
    else:
      self._settings.set("alarm.%s.state" % nr,"enabled")

    # copy current alarm to "snooze"-alarm
    if nr[0] == "-":
      # reuse snooze-alarm
      alarm = self._alarms[nr]
    else:
      # create new object
      alarm = Alarm(self._settings,nr)

    # set alarm.time to now + alarm.snooze
    dt = datetime.datetime.now()
    dt = dt + datetime.timedelta(minutes=int(alarm.snooze))
    alarm.time = dt.strftime("%H:%M")

    alarm.pending = True
    self._settings.log.msg("AlarmController: alarm[%s].time: %s" % (nr,alarm.time))
    self._settings.log.msg("AlarmController: alarm[%s].pend: %r" % (nr,alarm.pending))
    if nr[0] != "-":
      self._alarms["-%s" % nr] = alarm

    # reset snooze-state
    self._settings.set("_snooze",False)

  # --- date change listener   ---------------------------------------------

  def on_date(self,name,old,new):
    """ process date-change events """

    self._settings.log.msg("AlarmController: on_date(%s,%s)" % (old,new))

    # rebuild alarms at midnight
    # (old is None for very first invocation after initialization)
    if old:
      self._init_alarms()

  # --- time change listener   ---------------------------------------------

  def on_time(self,name,old,new):
    """ process time-change events """

    self._settings.log.msg("AlarmController: on_time(%s,%s)" % (old,new))

    self._settings.log.msg("AlarmController: checking alarms at %s" % new)
    for nr,alarm in self._alarms.items():
      if alarm.time <= new and alarm.pending:
        # update alarm-state and fire alarms
        self._settings.log.msg("AlarmController: activating alarm %s" % nr)
        self._settings.set("alarm."+nr+".state","ringing")
        self._fire_alarm(nr)

  # --- create alarm thread and run alarm   --------------------------------

  def _fire_alarm(self,nr):
    """ run alarm in it's own thread """

    # if we start with a "-" (snooze), we need the original alarm-nr as well
    if nr[0] == "-":
      orig_nr = nr[1:]
    else:
      orig_nr = nr

    # create Event to stop alarm
    self._alarms[nr].event = threading.Event()
    
    # query alarm-providers for alarm-threads
    alarm_threads = []
    for get_alarm in self._settings.alarm_provider:
      alarm = get_alarm(orig_nr,self._alarms[nr])
      if alarm:
        alarm_threads.append(alarm)

    # don't start alarm if no provider is present
    if not alarm_threads:
      self._alarms[nr].event = None
      return

    # stop all existing alarms
    for n,alarm in self._alarms.items():
      if n != nr:
        if self._alarms[n].event:
          self._settings.log.msg("AlarmController: stopping alarm %s" % n)
          self._alarms[n].event.set()
          # wait for thread to terminate
          self._alarms[n].thread.join()

    # create and run supervisor thread with alarm-threads and Event
    self._alarms[nr].thread = threading.Thread(
                             target=self._run_alarm,args=(nr,alarm_threads))
    self._settings.set("_current_alarm",nr)
    self._alarms[nr].thread.start()

  # --- run alarm thread   --------------------------------------------------

  def _run_alarm(self,nr,threads):
    """ run alarms """

    self._settings.log.msg("AlarmController: running alarm %s" % nr)

    # start threads of alarm-providers
    for t in threads:
      t.start()

    # poll for end-of-alarm (interruptable by global stop event)
    while not self._stop_event.wait(AlarmController.POLL_INTERVAL):
      # check if all threads have finished
      finished = True
      for t in threads:
        if t.is_alive():
          finished = False
          break

      if finished:
        self._settings.log.msg("AlarmController: alarm %s is finished" % nr)
        # reset state
        self._alarms[nr].event = None
        if self._settings.get("alarm."+nr+".state") == "ringing":
          self._settings.set("alarm."+nr+".state","enabled")
        break

    # we are either finished or interrupted by a global stop request
    self._settings.set("_current_alarm",None)
    if self._alarms[nr].event:
      # global stop request, so stop running alarms
      self._settings.log.msg("AlarmController: terminating alarm %s (global stop)" % nr)
      self._alarms[nr].event.set()
      # we don't bother to join here (program terminates), so just finish here
