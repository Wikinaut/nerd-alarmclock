#!/usr/bin/python
# --------------------------------------------------------------------------
# Class definition of AlarmController - manage alarms.
#
# Author: Bernhard Bablok
# License: GPL3
#
# Website: https://github.com/bablokb/nerd-alarmclock
#
# --------------------------------------------------------------------------

import time, threading

# --- value holder class for alarms   --------------------------------------

class Alarm(object):
  """ Value holder for alarms """

  # --- constructor (read settings)   --------------------------------------
  
  def __init__(self,settings,nr):
    """ Constructor """
    self.state = settings.get("alarm."+nr+".state")
    self.time  = settings.get("alarm."+nr+".time")
    self.days  = settings.get("alarm."+nr+".days")
    self.event = None

  # --- initialize pending-state of alarm   --------------------------------
  
  def init_pending(self,now=None,weekday=None):
    """ set pending-state of alarm """

    if not now:
      now = time.strftime("%H:%M")
    if not weekday:
      weekday = int(time.strftime("%u"))

    self.pending = ( self.state == "enabled" and
                     self.time > now and
                     weekday in self.days )

# --- AlarmController class   ----------------------------------------------

class AlarmController(object):
  """ AlarmController """

  # constants   ------------------------------------------------------------

  POLL_INTERVAL  = 5

  # initialize object   ----------------------------------------------------

  def __init__(self,settings):
    """ Constructor """

    self._settings   = settings
    self._stop_event = settings.stop_event
    self._init_alarms()

    # we need to register for changes in date and time
    self._settings.add_settings_listener('_current_date',self.on_date)
    self._settings.add_settings_listener('_current_time',self.on_time)

    # register for alarm-time and alarm-state changes
    for i in range(settings.MAX_ALARMS):
      self._settings.add_settings_listener('alarm.%d.time' % (i+1),
                                           self.on_alarm_time)
    self._settings.add_settings_listener('alarm.%d.state' % (i+1),
                                         self.on_alarm_state)

  # --- initialize alarms   ------------------------------------------------

  def _init_alarms(self):
    """ Initialize alarms """

    now = time.strftime("%H:%M")
    # initialize map of alarms
    self._alarms = {}
    weekday = int(time.strftime("%u"))
    for i in range(self._settings.MAX_ALARMS):
      nr    = str(i+1)
      alarm = Alarm(self._settings,nr)
      alarm.init_pending(now,weekday)
      self._settings.log.msg("alarm[%s].time: %s" % (nr,alarm.time))
      self._settings.log.msg("alarm[%s].pend: %r" % (nr,alarm.pending))
      self._alarms[nr] = alarm

  # --- update alarm-timers if time changes   ----------------------------

  def on_alarm_time(self,name,old,new):
    """ Update alarms on alarm-time change"""

    nr = name[6]
    self._settings.log.msg("updating alarm-time for alarm %s" % nr)
    alarm = self._alarms[nr]
    alarm.time = new
    alarm.init_pending()

  # --- update alarm-timers if state changes   ----------------------------

  def on_alarm_state(self,name,old,new):
    """ Update alarms on state-change """

    nr = name[6]
    self._settings.log.msg("updating alarm-state for alarm %s from %s to %s" %
                           (nr,old,new))

    # update data-structures
    alarm = self._alarms[nr]
    alarm.state = new
    alarm.init_pending()

    # stop alarm-thread if necessary
    if old == "ringing" and new == "enabled" and alarm.event:
      alarm.event.set()

  # --- date change listener   ---------------------------------------------

  def on_date(self,name,old,new):
    """ process date-change events """

    self._settings.log.msg("AlarmController.on_date(%s,%s)" % (old,new))

    # rebuild alarms at midnight
    # (old is None for very first invocation after initialization)
    if old:
      self._init_alarms()

  # --- time change listener   ---------------------------------------------

  def on_time(self,name,old,new):
    """ process time-change events """

    self._settings.log.msg("AlarmController.on_time(%s,%s)" % (old,new))

    self._settings.log.msg("checking alarms at %s" % new)
    for i in range(self._settings.MAX_ALARMS):
      nr = str(i+1)
      if self._alarms[nr].time <= new and self._alarms[nr].pending:
        # update alarm-state and fire alarms
        self._settings.log.msg("activating alarm %s" % nr)
        self._settings.set("alarm."+nr+".state","ringing")
        self._fire_alarm(nr)

  # --- create alarm thread and run alarm   --------------------------------

  def _fire_alarm(self,nr):
    """ run alarm in it's own thread """

    # create Event to stop alarms
    self._alarms[nr].event = threading.Event()
    
    # query alarm-providers for alarm-threads
    alarm_threads = []
    for get_alarm in self._settings.alarm_provider:
      alarm = get_alarm(nr,self._alarms[nr])
      if alarm:
        alarm_threads.append(alarm)

    # don't start alarm if no provider is present
    if not alarm_threads:
      self._alarms[nr].event = None
      return

    # stop all existing alarms
    for i in range(self._settings.MAX_ALARMS):
      n = str(i+1)
      if n != nr:
        if self._alarms[n].event:
          self._alarms[n].event.set()

    # create and run supervisor thread with alarm-threads and Event
    t = threading.Thread(target=self._run_alarm,args=(nr,alarm_threads))
    t.start()

  # --- run alarm thread   --------------------------------------------------

  def _run_alarm(self,nr,threads):
    """ run alarms """

    self._settings.log.msg("running alarm %s" % nr)

    # start threads of alarm-providers
    for t in threads:
      t.start()

    # poll for end-of-alarm (interruptable by global stop event)
    while not self._stop_event.wait(AlarmController.POLL_INTERVAL):
      # check if all threads have finished
      finished = True
      for t in threads:
        if t.is_alive():
          finished = False
          break

      if finished:
        self._settings.log.msg("alarm %s is finished" % nr)
        # reset state
        self._alarms[nr].event = None
        if self._settings.get("alarm."+nr+".state") == "ringing":
          self._settings.set("alarm."+nr+".state","enabled")
        break

    # we are either finished or interrupted by a global stop request
    if self._alarms[nr].event:
      # global stop request, so stop running alarms
      self._settings.log.msg("terminating alarm %s (global stop)" % nr)
      self._alarms[nr].event.set()
      # we don't bother to join, so just finish here
