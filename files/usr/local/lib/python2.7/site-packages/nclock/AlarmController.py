#!/usr/bin/python
# --------------------------------------------------------------------------
# Class definition of AlarmController - manage alarms.
#
# Author: Bernhard Bablok
# License: GPL3
#
# Website: https://github.com/bablokb/nerd-alarmclock
#
# --------------------------------------------------------------------------

import datetime, time, threading

# --- value holder class for alarms   --------------------------------------

class Alarm(object):
  """ Value holder for alarms """

  # --- constructor (read settings)   --------------------------------------
  
  def __init__(self,settings,nr):
    """ Constructor """
    self.nr     = nr
    self.state  = settings.get("alarm."+nr+".state")
    self.time   = settings.get("alarm."+nr+".time")
    self.tlo    = settings.get("alarm."+nr+".tlo")
    self.snooze = settings.get("alarm."+nr+".snooze")
    self.days   = settings.get("alarm."+nr+".days")
    self.event  = None

  # --- initialize pending-state of alarm   --------------------------------
  
  def init_pending(self,now=None,weekday=None):
    """ set pending-state of alarm """

    if self.state == "snooze":
      self.pending = True
      return

    if not now:
      now = time.strftime("%H:%M")
    if not weekday:
      weekday = int(time.strftime("%u"))

    self.pending = ( self.state == "enabled" and
                     self.time > now and
                     weekday in self.days )

# --- AlarmController class   ----------------------------------------------

class AlarmController(object):
  """ AlarmController """

  # constants   ------------------------------------------------------------

  POLL_INTERVAL  = 1

  # initialize object   ----------------------------------------------------

  def __init__(self,settings):
    """ Constructor """

    self._settings   = settings
    self._stop_event = settings.stop_event
    self._init_alarms()

    # we need to register for changes in date and time
    self._settings.add_settings_listener('_current_date',self.on_date)
    self._settings.add_settings_listener('_current_time',self.on_time)

    # register for alarm-time and alarm-state changes
    for i in range(settings.MAX_ALARMS):
      self._settings.add_settings_listener('alarm.%d.time' % (i+1),
                                           self.on_alarm_time)
      self._settings.add_settings_listener('alarm.%d.state' % (i+1),
                                           self.on_alarm_state)

  # --- initialize alarms   ------------------------------------------------

  def _init_alarms(self):
    """ Initialize alarms """

    now = time.strftime("%H:%M")
    # initialize map of alarms
    self._alarms = {}
    weekday = int(time.strftime("%u"))
    for i in range(self._settings.MAX_ALARMS):
      nr    = str(i+1)
      alarm = Alarm(self._settings,nr)
      alarm.init_pending(now,weekday)
      self._settings.log.msg("AlarmController: alarm[%s].time: %s" % (nr,alarm.time))
      self._settings.log.msg("AlarmController: alarm[%s].pend: %r" % (nr,alarm.pending))
      self._alarms[nr] = alarm

  # --- update alarm-timers if time changes   ----------------------------

  def on_alarm_time(self,name,old,new):
    """ Update alarms on alarm-time change"""

    nr = name[6]
    self._settings.log.msg("AlarmController: updating alarm-time for alarm %s" % nr)
    alarm = self._alarms[nr]
    alarm.time = new
    alarm.init_pending()
    self._settings.log.msg("AlarmController: alarm[%s].time: %s" % (nr,alarm.time))
    self._settings.log.msg("AlarmController: alarm[%s].pend: %r" % (nr,alarm.pending))

  # --- update alarm-timers if state changes   ----------------------------

  def on_alarm_state(self,name,old,new):
    """ Update alarms on state-change """

    nr = name[6]
    self._settings.log.msg("AlarmController: updating alarm-state for alarm %s from %s to %s" %
                           (nr,old,new))

    # update data-structures
    alarm = self._alarms[nr]
    alarm.state = new

    # set alarm.snooze_time to now + alarm.snooze
    if alarm.state == "snooze":
      dt = datetime.datetime.now()
      dt = dt + datetime.timedelta(minutes=int(alarm.snooze))
      alarm.snooze_time = dt.strftime("%H:%M")

    # update pending-state
    alarm.init_pending()

    # log status
    if alarm.state == "snooze":
      self._settings.log.msg("AlarmController: alarm[%s].time: %s" %
                             (nr,alarm.snooze_time))
    else:
      self._settings.log.msg("AlarmController: alarm[%s].time: %s" %
                             (nr,alarm.time))
    self._settings.log.msg("AlarmController: alarm[%s].pend: %r" %
                           (nr,alarm.pending))

    # stop alarm-thread if necessary
    if old == "ringing" and new in ["enabled","snooze"] and alarm.event:
      self._settings.log.msg("AlarmController: stopping alarm %s" % nr)
      alarm.event.set()

  # --- date change listener   ---------------------------------------------

  def on_date(self,name,old,new):
    """ process date-change events """

    self._settings.log.msg("AlarmController: on_date(%s,%s)" % (old,new))

    # rebuild alarms at midnight
    # (old is None for very first invocation after initialization)
    if old:
      self._init_alarms()

  # --- time change listener   ---------------------------------------------

  def on_time(self,name,old,new):
    """ process time-change events """

    self._settings.log.msg("AlarmController: on_time(%s,%s)" % (old,new))

    self._settings.log.msg("AlarmController: checking alarms at %s" % new)
    for nr,alarm in self._alarms.items():
      if (alarm.state == "enabled" and alarm.time <= new and alarm.pending) or (
        alarm.state == "snooze" and alarm.snooze_time <= new and alarm.pending):
        # update alarm-state and fire alarms
        self._settings.log.msg("AlarmController: activating alarm %s" % nr)
        self._settings.set("alarm."+nr+".state","ringing")
        self._fire_alarm(nr)

  # --- create alarm thread and run alarm   --------------------------------

  def _fire_alarm(self,nr):
    """ run alarm in it's own thread """

    # create Event to stop alarm
    self._alarms[nr].event = threading.Event()
    
    # query alarm-providers for alarm-threads
    alarm_threads = []
    for get_alarm in self._settings.alarm_provider:
      alarm = get_alarm(nr,self._alarms[nr])
      if alarm:
        alarm_threads.append(alarm)

    # don't start alarm if no provider is present
    if not alarm_threads:
      self._alarms[nr].event = None
      return

    # stop all existing alarms
    for n,alarm in self._alarms.items():
      if n != nr:
        if self._alarms[n].event:
          self._settings.log.msg("AlarmController: stopping alarm %s" % n)
          self._alarms[n].event.set()
          # wait for thread to terminate
          self._alarms[n].thread.join()

    # create and run supervisor thread with alarm-threads and Event
    self._alarms[nr].thread = threading.Thread(
                             target=self._run_alarm,args=(nr,alarm_threads))
    self._settings.set("_current_alarm",nr)
    self._alarms[nr].thread.start()

  # --- run alarm thread   --------------------------------------------------

  def _run_alarm(self,nr,threads):
    """ run alarms """

    self._settings.log.msg("AlarmController: running alarm %s" % nr)

    # start threads of alarm-providers
    for t in threads:
      t.start()

    # poll for end-of-alarm (interruptable by global stop event)
    while not self._stop_event.wait(AlarmController.POLL_INTERVAL):
      # check if all threads have finished
      finished = True
      for t in threads:
        if t.is_alive():
          finished = False
          break

      if finished:
        self._settings.log.msg("AlarmController: alarm %s is finished" % nr)
        # reset state
        self._alarms[nr].event = None
        if self._settings.get("alarm."+nr+".state") == "ringing":
          self._settings.set("alarm."+nr+".state","enabled")
        break
        # toggle lights-off-mode if configured
        if self._alarms[nr].tlo == 'enabled':
          self._settings.log.msg("AlarmController: toggling lights")
          old = self._settings.get("_lights_off")
          self._settings.set("_lights_off",not old)

    # we are either finished or interrupted by a global stop request
    self._settings.set("_current_alarm",None)
    if self._alarms[nr].event:
      # global stop request, so stop running alarms
      self._settings.log.msg("AlarmController: terminating alarm %s (global stop)" % nr)
      self._alarms[nr].event.set()
      # we don't bother to join here (program terminates), so just finish here
