#!/usr/bin/python
# --------------------------------------------------------------------------
# Class definition of BotThread - a telegram bot to control the clock
#
# Please edit /etc/nerd-alarmclock.conf to configure this thread
#
# Author: Bernhard Bablok
# License: GPL3
#
# Website: https://github.com/bablokb/nerd-alarmclock
#
# --------------------------------------------------------------------------

import ConfigParser, pprint, traceback, re
from threading import Thread

import telepot

class BotThread(Thread):
  """ telegram bot thread """

  # constants   ------------------------------------------------------------

  POLL_INTERVAL  = 0.1
  UPDATE_TIMEOUT = 5

  # initialize object   ----------------------------------------------------

  def __init__(self,settings):
    """ Constructor """
    
    super(BotThread,self).__init__(name="BotThread")
    self._settings   = settings
    self._stop_event = settings.stop_event
    self._bot_id     = settings.config_parser.get("BOT","bot_id")
    self._user_id    = settings.config_parser.getint("BOT","user_id")

    # handler
    self._handler = [
      (re.compile("/start"),self._do_start),
      (re.compile("/help"),self._do_help),
      (re.compile("/settings"),self._do_settings),
      (re.compile("/restart"),self._do_restart),
      (re.compile("/reboot"),self._do_reboot),
      (re.compile("/shutdown"),self._do_shutdown),
      (re.compile(".*neustart.*",re.I),self._do_reboot),
      (re.compile("/alarm"),self._do_set_alarm),
      (re.compile(".*weck.*",re.I),self._do_set_alarm)
    ]

    # create bot
    self._bot = telepot.Bot(self._bot_id)

  # handler for /start   ---------------------------------------------------

  def _do_start(self,chat_id,text):
    """ process the /start command """

    response = (
      "Hi Bernhard,\n"
      "this is your NerdClockController.\n\n"
      "What can I do for you?"
      )
    self._bot.sendMessage(chat_id,response)
    
  # handler for /help   ----------------------------------------------------

  def _do_help(self,chat_id,text):
    """ process the /help command """

    response = (
      "Hi Bernhard,\n"
      "use /settings to see the current settings,\n"
      "use /reboot to reboot the system,\n"
      "use /shutdown to shutdown the system,\n"
      "use /alarm to set alarm-attributes."
      )
    self._bot.sendMessage(chat_id,response)

  # handler for /settings   ------------------------------------------------

  def _do_settings(self,chat_id,text):
    """ process the /settings command """
    self._settings.log.msg("processing /settings")
    self._bot.sendMessage(chat_id,"sorry, not implemented yet!")

  # handler for /rstart   --------------------------------------------------

  def _do_restart(self,chat_id,text):
    """ process the /restart command """
    self._settings.log.msg("processing /restart")
    self._bot.sendMessage(chat_id,"sorry, not implemented yet!")

  # handler for /reboot   --------------------------------------------------

  def _do_reboot(self,chat_id,text):
    """ process the /reboot command """
    self._settings.log.msg("processing /reboot")
    self._bot.sendMessage(chat_id,"sorry, not implemented yet!")

  # handler for /shutdown   ------------------------------------------------

  def _do_shutdown(self,chat_id,text):
    """ process the /shutdown command """
    self._settings.log.msg("processing /shutdown")
    self._bot.sendMessage(chat_id,"sorry, not implemented yet!")

  # handler for setting the alarm   ----------------------------------------

  def _do_set_alarm(self,chat_id,text):
    """ process the /alarm command """
    self._settings.log.msg("processing set_alarm")
    self._bot.sendMessage(chat_id,"sorry, not implemented yet!")

  # fallback handler for unknown commands   --------------------------------

  def _do_fallback(self,chat_id,text):
    """ process unhandled messages """
    self._settings.log.msg("cannot interpret %s" % text)
    response = "sorry, but I don't understand '%s'" % text
    self._bot.sendMessage(chat_id,response)

  # handle updates from telegram   -----------------------------------------

  def _handle_updates(self,update):
    """ handle updates from telegram. This is only a multiplexer method """

    # we only support private text messages and only messages from self._user_id
    chat = update['message']['chat']
    if chat['type'] != "private" or chat['id'] != self._user_id:
      return
    else:
      msg = update['message']
      content_type, chat_type, chat_id = telepot.glance(msg)
      if content_type != 'text':
        return

    # do some text analysis and pass messages to handlers
    text = msg['text']
    for (regex,handler) in self._handler:
      if regex.match(text):
        handler(chat_id,text)
        return
    self._do_fallback(chat_id,text)

  # run the thread   -------------------------------------------------------

  def run(self):
    self._settings.log.msg("running BotThread")
    offset = None
    while not self._stop_event.wait(BotThread.POLL_INTERVAL):
      self._settings.log.msg("polling ...")
      try:
        result = self._bot.getUpdates(offset=offset,
                                      timeout=BotThread.UPDATE_TIMEOUT)

        if len(result) > 0:
          # No sort. Trust server to give messages in correct order.
          for update in result:
            self._handle_updates(update)
            offset = update['update_id'] + 1

      except:
        # traceback.print_exc()
        self._settings.log.msg("exception while polling telegram")

    self._settings.log.msg("terminating BotThread")
