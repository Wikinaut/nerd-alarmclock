#!/usr/bin/python
# --------------------------------------------------------------------------
# Class definition of BotThread - a telegram bot to control the clock
#
# Please edit /etc/nerd-alarmclock.conf to configure this thread
#
# Author: Bernhard Bablok
# License: GPL3
#
# Website: https://github.com/bablokb/nerd-alarmclock
#
# --------------------------------------------------------------------------

import ConfigParser, traceback, re, os, signal, json, pprint
from threading import Thread

import telepot
from telepot.namedtuple import InlineKeyboardMarkup, InlineKeyboardButton
from telepot.exception import TelegramError

class BotThread(Thread):
  """ telegram bot thread """

  # constants   ------------------------------------------------------------

  POLL_SHORT = 0.1
  POLL_LONG  = 15

  # initialize object   ----------------------------------------------------

  def __init__(self,settings):
    """ Constructor """
    
    super(BotThread,self).__init__(name="BotThread")
    self._settings   = settings
    self._stop_event = settings.stop_event
    self._bot_id     = settings.config_parser.get("BOT","bot_id")
    self._user_id    = settings.config_parser.getint("BOT","user_id")
    self._dialog     = None

    # handler
    self._handler = [
      (re.compile("/start"),self._do_start),
      (re.compile("/help"),self._do_help),
      (re.compile("/settings"),self._do_settings),
      (re.compile("/restart"),self._do_restart),
      (re.compile("/reboot"),self._do_reboot),
      (re.compile("/shutdown"),self._do_shutdown),
      (re.compile(".*neustart.*",re.I),self._do_reboot),
      (re.compile("/alarm"),self._do_set_alarm),
      (re.compile(".*weck.*",re.I),self._do_set_alarm)
    ]

    # create bot
    self._bot = telepot.Bot(self._bot_id)

  # handler for /start   ---------------------------------------------------

  def _do_start(self,chat_id,text):
    """ process the /start command """

    response = (
      "Hi Bernhard,\n"
      "this is your NerdClockController.\n\n"
      "What can I do for you?"
      )
    self._bot.sendMessage(chat_id,response)
    
  # handler for /help   ----------------------------------------------------

  def _do_help(self,chat_id,text):
    """ process the /help command """

    response = (
      "Hi Bernhard,\n"
      "use /settings to see the current settings,\n"
      "use /restart to restart the clock,\n"
      "use /reboot to reboot the system,\n"
      "use /shutdown to shutdown the system,\n"
      "use /alarm to set alarm-attributes."
      )
    self._bot.sendMessage(chat_id,response)

  # handler for /settings   ------------------------------------------------

  def _do_settings(self,chat_id,text):
    """ process the /settings command """

    self._settings.log.msg("processing /settings")
    self._bot.sendMessage(chat_id,"sorry, not implemented yet!")

  # handler for /restart   -------------------------------------------------

  def _do_restart(self,chat_id,text):
    """ process the /restart command """

    self._settings.log.msg("processing /restart")
    self._do_restart = True
    self._bot.sendMessage(chat_id,"Really restart?",
                          reply_markup=self._yesno_keyboard("restart"))

  # callback-handler for /restart   ----------------------------------------

  def _do_restart_callback(self,query_id,chat_id,value):
    """ callback-handler for the /restart command """

    # prevent multiple use of the keyboard
    if not self._do_restart:
      # ignore repeated keyboard press
      self._bot.answerCallbackQuery(query_id,"keyboards are one-time use!",
                                    show_alert=True)
      return
    else:
      self._do_restart = False

    if value == 'no':
      self._bot.answerCallbackQuery(query_id)
      self._bot.sendMessage(chat_id,"canceled restart")
    else:
      self._bot.answerCallbackQuery(query_id)
      self._bot.sendMessage(chat_id,"restarting the clock")
      os.system("sudo /sbin/systemctl restart nerd-alarmclock.service &")
      os.kill(os.getpid(), signal.SIGINT)

  # handler for /reboot   --------------------------------------------------

  def _do_reboot(self,chat_id,text):
    """ process the /reboot command """

    self._settings.log.msg("processing /reboot")
    self._do_reboot = True
    self._bot.sendMessage(chat_id,"Really reboot?",
                          reply_markup=self._yesno_keyboard("reboot"))

  # callback-handler for /reboot   -----------------------------------------

  def _do_reboot_callback(self,query_id,chat_id,value):
    """ callback-handler for the /reboot command """

    # prevent multiple use of the keyboard
    if not self._do_reboot:
      # ignore repeated keyboard press
      self._bot.answerCallbackQuery(query_id,"keyboards are one-time use!",
                                    show_alert=True)
      return
    else:
      self._do_reboot = False

    if value == 'no':
      self._bot.answerCallbackQuery(query_id)
      self._bot.sendMessage(chat_id,"canceled reboot")
    else:
      self._bot.answerCallbackQuery(query_id)
      self._bot.sendMessage(chat_id,"rebooting the system")
      os.system("sudo /sbin/reboot &")
      os.kill(os.getpid(), signal.SIGINT)

  # handler for /shutdown   ------------------------------------------------

  def _do_shutdown(self,chat_id,text):
    """ process the /shutdown command """

    self._settings.log.msg("processing /shutdown")
    self._do_shutdown = True
    self._bot.sendMessage(chat_id,"Really shutdown?",
                          reply_markup=self._yesno_keyboard("shutdown"))

  # callback-handler for /shutdown   ---------------------------------------

  def _do_shutdown_callback(self,query_id,chat_id,value):
    """ callback-handler for the /shutdown command """

    # prevent multiple use of the keyboard
    if not self._do_shutdown:
      # ignore repeated keyboard press
      self._bot.answerCallbackQuery(query_id,"keyboards are one-time use!",
                                    show_alert=True)
      return
    else:
      self._do_shutdown = False

    if value == 'no':
      self._bot.answerCallbackQuery(query_id)
      self._bot.sendMessage(chat_id,"canceled shutdown")
    else:
      self._bot.answerCallbackQuery(query_id)
      self._bot.sendMessage(chat_id,"shutting down the system")
      os.system("sudo /sbin/halt &")
      os.kill(os.getpid(), signal.SIGINT)

  # handler for setting the alarm   ----------------------------------------

  def _do_set_alarm(self,chat_id,text):
    """ process the /alarm command """
    self._settings.log.msg("processing set_alarm")

    # send a keyboard with a button for each alarm
    buttons = []
    for i in range(4):
      nr = str(i+1)
      button = InlineKeyboardButton(text=nr,
                              callback_data='{"step":"alarm", "value": %s}' % nr)
      buttons.append(button)

    keyboard = InlineKeyboardMarkup(inline_keyboard=[buttons])
    self._dialog = self._alarm_dialog
    self._bot.sendMessage(chat_id,"Select alarm",reply_markup=keyboard)

  # set_alarm dialog   ----------------------------------------------------

  def _alarm_dialog(self,chat_id=None,query_id=None,step=None,value=None,text=None):
    """ process steps of the alarm-dialog """

    self._settings.log.msg("alarm-dialog step: %s, value: %s, text: %s" %
                           (step,value,text))

    # acknowledge last callback
    if query_id:
      self._bot.answerCallbackQuery(query_id)

    # empty step is from normal message -> use saved value
    if not step:
      step = self._step
    self._settings.log.msg("alarm-dialog step: %s" % step)

    # process dialog-step
    if step == "alarm":
      # save value of last step (alarm-selection) and query state
      self._alarm_nr    = value
      self._alarm_state = self._settings.get("alarm.%s.state" % value)
      self._alarm_time  = self._settings.get("alarm.%s.time"  % value)
      self._alarm_days  = self._settings.get("alarm.%s.days"  % value)
      self._led_cfg     = self._settings.get("alarm.%s.led"   % value)
      self._alarm_led   = self._led_cfg['name']
      self._alarm_dur   = self._led_cfg['duration']

      text = "enable" if self._alarm_state == "disabled" else "disable"
      arg  = text + "d"
      buttons = [[InlineKeyboardButton(text=text,
                         callback_data='{"step":"state", "value": "%s"}' % arg)],
                 [InlineKeyboardButton(text="continue",
                         callback_data='{"step":"state", "value": "noop"}')]
                 ]
      keyboard = InlineKeyboardMarkup(inline_keyboard=buttons)
      self._bot.sendMessage(chat_id,
            ( "Alarm %s:\n"
              "  state:    %s\n"
              "  time:     %s\n"
              "  days:     %s\n"
              "  alarm:    %s\n\n"
              "  duration: %s\n\n"
              "Change state of alarm") % (
                 self._alarm_nr,self._alarm_state,self._alarm_time,
                 self._alarm_days,self._alarm_led, self._alarm_dur),reply_markup=keyboard)

    elif step == "state":
      if value != "noop":
        # save state from callback
        self._alarm_state = value
        self._settings.set("alarm.%s.state" % self._alarm_nr,value)

      # prepare time-selection
      self._step = "time"
      self._bot.sendMessage(chat_id,"Enter the time:")

    elif step == "time":
      # TODO: check format
      value = text
      if len(value) > 3:
        self._alarm_time = value
        self._settings.set("alarm.%s.time" % self._alarm_nr,self._alarm_time)

      # prepare days-step
      self._step = "days"
      self._bot.sendMessage(chat_id,"Enter days (Mo=1 etc.):")

    elif step == "days":
      value = text
      if value and re.match("[0-9 ,\t\n]+",value):
        self._alarm_days = [int(v) for v in re.split("\W+",value)]
        self._settings.set("alarm.%s.days" % self._alarm_nr,self._alarm_days)

      # prepare alarm-selection
      buttons = []
      for alarm in self._settings.get("_led_alarms"):
        button = [InlineKeyboardButton(text=alarm,
                         callback_data='{"step":"led", "value": "%s"}' % alarm)]
        buttons.append(button)
      keyboard = InlineKeyboardMarkup(inline_keyboard=buttons)
      self._bot.sendMessage(chat_id,"Select LED-alarm",reply_markup=keyboard)

    elif step == "led":
      pprint.pprint(self._led_cfg)
      self._led_cfg['name'] = value
      self._settings.set("alarm.%s.led" % self._alarm_nr,self._led_cfg)

      # prepare duration
      self._step = "duration"
      self._bot.sendMessage(chat_id,"set duration:")

    elif step == "duration":
      pprint.pprint(self._led_cfg)
      value = text
      self._led_cfg['duration'] = value
      if value and re.match("[0-9]+",value):
        self._settings.set("alarm.%s.led" % self._alarm_nr,self._led_cfg)
        self._dialog = None
        self._bot.sendMessage(chat_id,
                       "alarm %s configured successfully!" % self._alarm_nr)

  # fallback handler for unknown commands   --------------------------------

  def _do_fallback(self,chat_id,text):
    """ process unhandled messages """
    self._dialog = None

    self._settings.log.msg("cannot interpret %s" % text)
    response = "sorry, but I don't understand '%s'" % text
    self._bot.sendMessage(chat_id,response)

  # handle updates from telegram   -----------------------------------------

  def _handle_updates(self,update):
    """ handle updates from telegram. This is only a multiplexer method """

    if update.has_key('message'):
      self._handle_message(update['message'])
    else:
      self._handle_callback(update['callback_query'])

  # handle text messages   ------------------------------------------------

  def _handle_message(self,msg):
    """ handle objects of type message from telegram """
    chat = msg['chat']
    content_type, chat_type, chat_id = telepot.glance(msg)
    if content_type != 'text':
      return

    # we only support private text messages and only messages from self._user_id
    if chat['type'] != "private" or msg['from']['id'] != self._user_id:
      self._settings.log.msg("ignoring message (wrong type of id)")
      return

    text = msg['text']
    if text[0] == '/':
      self._dialog = None

    if self._dialog:
      self._dialog(chat_id=chat_id,text=text)
      return

    # do some text analysis and pass messages to handlers
    for (regex,handler) in self._handler:
      if regex.match(text):
        handler(chat_id,text)
        return
    self._do_fallback(chat_id,text)

  # handle callbacks   ----------------------------------------------------

  def _handle_callback(self,query):
    """ handle objects of type callback_query from telegram """

    if query['from']['id'] != self._user_id:
      self._settings.log.msg("ignoring message (wrong id)")
      return

    query_id      = query['id']
    chat_id       = query['message']['chat']['id']
    callback_data = query['data']
    self._settings.log.msg("callback_data: %s" % callback_data)

    # extract and call callback-function
    cinfo = json.loads(callback_data)

    # check for active dialog
    if self._dialog:
      self._dialog(chat_id=chat_id,query_id=query_id,**cinfo)
      return

    func_name = "_do_%s_callback" % cinfo['name']
    if hasattr(self,func_name):
      self._settings.log.msg("executing %s(%s)" % (func_name,cinfo['value']))
      func = getattr(self,func_name)
      func(query_id,chat_id,cinfo['value'])
    else:
      self._settings.log.msg("method %s not found" % func_name)

  # return yes/no keyboard   ------------------------------------------------

  def _yesno_keyboard(self,callback_name):
    return InlineKeyboardMarkup(
      inline_keyboard=[
        [InlineKeyboardButton(text='No',
                 callback_data='{"name": "%s", "value": "no"}' % callback_name),
         InlineKeyboardButton(text='Yes',
                 callback_data='{"name": "%s", "value": "yes"}' % callback_name),
         ],
        ])

  # run the thread   -------------------------------------------------------

  def run(self):
    self._settings.log.msg("running BotThread")
    offset = None

    # start configuration of poll-timeouts
    poll_event    = BotThread.POLL_SHORT
    poll_telegram = BotThread.POLL_LONG

    while not self._stop_event.wait(poll_event):
      self._settings.log.msg("polling telegram ...")
      try:
        result = self._bot.getUpdates(offset=offset,
                                      timeout=poll_telegram)

        if len(result) > 0:
          # No sort. Trust server to give messages in correct order.
          for update in result:
            offset = update['update_id'] + 1
            self._handle_updates(update)

        # reset timeouts to standard
        poll_event    = BotThread.POLL_SHORT
        poll_telegram = BotThread.POLL_LONG

      except TelegramError as e:
        if e.error_code == 404:
          # wrong bot-id??
          self._settings.log.msg("received 404 - not found. Wrong bot-ID?")
          break
        else:
          self._settings.log.msg(traceback.format_exc())
          # swap timeouts, since something is going wrong
          poll_event    = BotThread.POLL_LONG
          poll_telegram = BotThread.POLL_SHORT

      except:
        self._settings.log.msg(traceback.format_exc())
        # swap timeouts, since something is going wrong
        poll_event    = BotThread.POLL_LONG
        poll_telegram = BotThread.POLL_SHORT

    self._settings.log.msg("terminating BotThread")
