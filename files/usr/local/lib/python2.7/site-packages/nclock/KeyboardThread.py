#!/usr/bin/python
# --------------------------------------------------------------------------
# Class definition of KeyboardThread - this thread controls the key-pad
#
# Author: Bernhard Bablok
# License: GPL3
#
# Website: https://github.com/bablokb/nerd-alarmclock
#
# --------------------------------------------------------------------------

import time, select, os
from threading import Thread

class KeyboardThread(Thread):
  """ Keyboard thread """

  # constants   ------------------------------------------------------------

  POLL_INTERVAL  = 15
  GPIO_POLL_PIPE = "/var/run/gpio-poll.fifo"

  BUTTONS = {              # map GPIOxx to button-number
    "17": "1",
     "4": "2",
    "22": "3",
    "27": "4"
    }

  # initialize object   ----------------------------------------------------

  def __init__(self,settings):
    """ Constructor """
    
    super(KeyboardThread,self).__init__(name="KeyboardThread")
    self._settings   = settings
    self._stop_event = settings.stop_event
    self._state      = "def"

  # run the thread   -------------------------------------------------------

  def run(self):
    """ run-method of thread """
    self._settings.log.msg("running KeyboardThread")

    # make sure the open call does not block
    p_fd = os.open(KeyboardThread.GPIO_POLL_PIPE,os.O_RDONLY|os.O_NONBLOCK)
    pipe = os.fdopen(p_fd,"r")
    poll_obj = select.poll()
    poll_obj.register(p_fd,select.POLLPRI|select.POLLIN)

    while True:
      self._settings.log.msg("polling %s" % KeyboardThread.GPIO_POLL_PIPE)
      poll_result = poll_obj.poll(KeyboardThread.POLL_INTERVAL*1000)
      for (fd,event) in poll_result:
        self._settings.log.msg("processing poll-event: %d" % event)

        # do some sanity checks
        if event & select.POLLHUP == select.POLLHUP:
          self._settings.log.msg("POLLHUP received")
          # we just wait and hope the gpio-manager comes back
          if self._stop_event.wait(KeyboardThread.POLL_INTERVAL):
            break
          continue

        line = pipe.readline()
        self._process_event(line)
      if self._stop_event.wait(0.01):
        break

    poll_obj.unregister(pipe)
    # os.close(p_fd) is not necessary, because closing pipe will close the fd
    self._settings.log.msg("terminating KeyboardThread")

  # --- process events (multiplex)   ---------------------------------------

  def _process_event(self,event):
    self._settings.log.msg("processing event: %s" % event)
    [gpio,state,stime,rtime] = event.split(" ")
    try:
      func_name = "btn" + KeyboardThread.BUTTONS[gpio] + "_" + self._state
      func = getattr(self,func_name)
      func(state,stime,rtime)
    except KeyError:
      self._settings.log.msg("invalid GPIO-nr: %s" % gpio)
    except:
      raise

  # --- process default action for button 1   ------------------------------

  def btn1_def(self,state,stime,rtime):
    """ process default action for button 1 """
    self._settings.log.msg("Button 1, default function")
    self.change_alarm_state("1")

  # --- process overlay action for button 1   ------------------------------

  def btn1_ovl(self,state,stime,rtime):
    """ process overlay action for button 1 """
    self._settings.log.msg("Button 1, overlay function")
    self.cycle_display_brightness()

  # --- process default action for button 2   ------------------------------

  def btn2_def(self,state,stime,rtime):
    """ process default action for button 2 """
    self._settings.log.msg("Button 2, default function")
    self.change_alarm_state("2")

  # --- process overlay action for button 2   ------------------------------

  def btn2_ovl(self,state,stime,rtime):
    """ process overlay action for button 2 """
    self._settings.log.msg("Button 2, overlay function")
    self.cycle_display_mode()

  # --- process default action for button 3   ------------------------------

  def btn3_def(self,state,stime,rtime):
    """ process default action for button 3 """
    self._settings.log.msg("Button 3, default function")
    self.change_alarm_state("3")

  # --- process overlay action for button 3   ------------------------------

  def btn3_ovl(self,state,stime,rtime):
    """ process overlay action for button 3 """
    self._settings.log.msg("Button 3, overlay function")
    self.cycle_led_brightness()

  # --- process default action for button 4   ------------------------------

  def btn4_def(self,state,stime,rtime):
    """ process default action for button 4 """
    self._settings.log.msg("Button 4, default function")

    # only react to state==0 and decide, if short or long press
    if state == "1":
      self._settings.log.msg("Button 4, ignoring state 1")
      return
    if not self._toggle_state(float(stime)):
      # normal short-press event
      self.change_alarm_state("4")

  # --- process overlay action for button 4   ------------------------------

  def btn4_ovl(self,state,stime,rtime):
    """ process overlay action for button 4 """
    self._settings.log.msg("Button 4, overlay function")

    # only react to state==0 and decide, if short or long press
    if state == "1":
      self._settings.log.msg("Button 4, ignoring state 1")
      return
    if not self._toggle_state(float(stime)):
      # normal short-press event
      self.cycle_led_mode()

  # --- toggle button state   ----------------------------------------------

  def _toggle_state(self,stime):
    """ toggle state of buttons if long pressed (return True if handled)"""

    self._settings.log.msg("_toggle_state() with stime=%g" % stime)
    if stime > 5:
      # ignore very long press, typically an artifact during init
      self._settings.log.msg("Button 4, ignoring stime > 5")
      return True
    elif stime > 1:
      # toggle overlay state
      if self._state == "def":
        self._state = "ovl"
        self._settings.set("_do_config","on")
        self._settings.log.msg("Button 4, changed state to ovl")
      else:
        self._state = "def"
        self._settings.set("_do_config","off")
        self._settings.log.msg("Button 4, changed state to def")
      return True
    else:
      return False

  # --- change alarm state   -----------------------------------------------

  def change_alarm_state(self,button):
    """ change the state of the given button """
    self._settings.log.msg("changing state of button %s" % button)

    old = self._settings.get("alarm."+button+".state")

    if old == "disabled":
      new = "enabled"
    elif old == "enabled":
      new = "disabled"
    elif old == "ringing":
      new = "enabled"

    self._settings.set("alarm."+button+".state",new)

  # --- cylcle display brightness   ---------------------------------------

  def cycle_display_brightness(self):
    self._settings.log.msg("changing display brightness")
    mode = self._settings.get("_day_mode")
    cfg  = "display.brightness." + mode
    old = self._settings.get(cfg)
    new = ( old + 1) % 5
    self._settings.set(cfg,new)

  # --- cylcle LED brightness   -------------------------------------------

  def cycle_led_brightness(self):
    self._settings.log.msg("changing led brightness")
    mode = self._settings.get("_day_mode")
    cfg  = "led.brightness." + mode
    old = self._settings.get(cfg)
    new = ( old + 1) % 5
    self._settings.set(cfg,new)

  # --- cylcle display mode   ---------------------------------------------

  def cycle_display_mode(self):
    self._settings.log.msg("changing display mode")

  # --- cylcle LED brightness   -------------------------------------------

  def cycle_led_mode(self):
    self._settings.log.msg("changing led mode")
