#!/usr/bin/python
# --------------------------------------------------------------------------
# Class definition of KeyboardThread - this thread handles key-press events.
#
# Author: Bernhard Bablok
# License: GPL3
#
# Website: https://github.com/bablokb/nerd-alarmclock
#
# --------------------------------------------------------------------------

import time, select, os
from threading import Thread

from KeyController import KeyController

class KeyboardThread(Thread,KeyController):
  """ Keyboard thread """

  # constants   ------------------------------------------------------------

  POLL_INTERVAL  = 15
  GPIO_POLL_PIPE = "/var/run/gpio-poll.fifo"

  # initialize object   ----------------------------------------------------

  def __init__(self,settings):
    """ Constructor """
    
    super(KeyboardThread,self).__init__(name="KeyboardThread")
    self.init(settings)
    self._state = "DEF"
    self._create_map()

  # build the mapping tabe (GPIO to function)   ----------------------------

  def _create_map(self):
    """ build the mapping table """

    self._gpio_map = {}
    for (btn,gpio) in self._settings.get_values('GPIO'):
      self._settings.log.msg("KeyboardThread: GPIO for %s: %s" % (btn,gpio))
      self._gpio_map[gpio] = btn

    # mapping of buttons to methods
    self.METHODS = [
      # short-press
      { ('BTN1',  'DEF'):     self.change_alarm_state,
        ('BTN2',  'DEF'):     self.change_alarm_state,
        ('BTN3',  'DEF'):     self.change_alarm_state,
        ('BTN4',  'DEF'):     self.change_alarm_state,
        ('SNZ',   'DEF'):     self.handle_snz,
        ('EK1_SW','DEF'):     self.radio_next_channel_list,
        ('EK2_SW','DEF'):     self.radio_toggle,

        ('BTN1','OVL_BTN1'):  self.cycle_led_brightness,
        ('BTN2','OVL_BTN1'):  self.cycle_display_brightness,
        ('BTN3','OVL_BTN1'):  self.cycle_led_mode,
        ('BTN4','OVL_BTN1'):  self.cycle_display_mode,

        ('BTN1','OVL_BTN2'):  self.restart_service,
        ('BTN2','OVL_BTN2'):  self.reboot_system,
        ('BTN3','OVL_BTN2'):  self.shutdown_system
        },
      # long press
      { ('BTN1','DEF'):       self.toggle_state,
        ('BTN1','OVL_BTN1'):  self.toggle_state,
        ('BTN2','DEF'):       self.toggle_state,
        ('BTN2','OVL_BTN2'):  self.toggle_state
      }]

  # run the thread   -------------------------------------------------------

  def run(self):
    """ run-method of thread """
    self._settings.log.msg("KeyboardThread: running KeyboardThread")

    # wait for pipe
    pipe_wait = 0.5
    while not os.path.exists(KeyboardThread.GPIO_POLL_PIPE):
      if pipe_wait < KeyboardThread.POLL_INTERVAL/2:
        pipe_wait *= 2
      self._settings.log.msg("KeyboardThread: waiting for pipe")
      if self._stop_event.wait(pipe_wait):
        self._settings.log.msg("KeyboardThread: terminating KeyboardThread")
        return

    # make sure the open call does not block
    p_fd = os.open(KeyboardThread.GPIO_POLL_PIPE,os.O_RDONLY|os.O_NONBLOCK)
    pipe = os.fdopen(p_fd,"r")
    poll_obj = select.poll()
    poll_obj.register(p_fd,select.POLLPRI|select.POLLIN)

    while True:
      self._settings.log.msg("KeyboardThread: polling %s" % KeyboardThread.GPIO_POLL_PIPE)
      poll_result = poll_obj.poll(KeyboardThread.POLL_INTERVAL*1000)
      for (fd,event) in poll_result:
        #self._settings.log.msg("KeyboardThread: processing poll-event: %d" % event)

        # do some sanity checks
        if event & select.POLLHUP == select.POLLHUP:
          self._settings.log.msg("KeyboardThread: POLLHUP received")
          # we just wait and hope the gpio-manager comes back
          if self._stop_event.wait(KeyboardThread.POLL_INTERVAL):
            break
          continue

        line = pipe.readline()
        self._process_event(line)
      if self._stop_event.wait(0.01):
        break

    poll_obj.unregister(pipe)
    # os.close(p_fd) is not necessary, because closing pipe will close the fd
    self._settings.log.msg("KeyboardThread: terminating KeyboardThread")

  # --- process events (multiplex)   ---------------------------------------

  def _process_event(self,event):
    self._settings.log.msg("KeyboardThread: processing event: %s" % event)
    [gpio,state,stime,rtime] = event.split(" ")
    stime = float(stime)

    # check for valid GPIO (should not happen)
    if not self._gpio_map.has_key(gpio):
      self._settings.log.msg("KeyboardThread: invalid GPIO-nr: %s" % gpio)
      return

    # ignore high-state
    if state == "1":
      return

    # check short/long press
    if stime > 5:
      # ignore very long press, typically an artifact during init
      self._settings.log.msg("KeyboardThread: GPIO %s, ignoring stime > 5" % gpio)
      return
    elif stime > 1:
      self._settings.log.msg("KeyboardThread: GPIO %s, long press" % gpio)
      long_press = 1
    else:
      self._settings.log.msg("KeyboardThread: GPIO %s, short press" % gpio)
      long_press = 0

    # map info to method and execute
    btn = self._gpio_map[gpio]
    if self.METHODS[long_press].has_key((btn,self._state)):
      func = self.METHODS[long_press][(btn,self._state)]
      func(btn)
    else:
      self._settings.log.msg("KeyboardThread: no method defined for (%s,%s)" %
                             (btn,self._state))
