#!/usr/bin/python
# --------------------------------------------------------------------------
# Class definition of SoundController - utility functions for sound output.
#
# Please edit /etc/nerd-alarmclock.conf to configure this thread
#
# Author: Bernhard Bablok
# License: GPL3
#
# Website: https://github.com/bablokb/nerd-alarmclock
#
# --------------------------------------------------------------------------

import os, signal, subprocess, shlex, time, threading, json

simulate=False

class SoundController(object):
  """ Utility functions for sound output """

  # initialize object   ----------------------------------------------------

  def __init__(self,settings):
    """ Constructor """
    self._settings    = settings
    self._lock        = threading.Lock()
    self._mpg123_opts = settings.get_value('SOUND','mpg123_opts','')
    self._mixer       = settings.get_value('SOUND','mixer','PCM')

    settings.add_alarm_provider(self.get_alarm)
    settings.set("_sound_alarms",self._get_sounds())

  # --- initialize alarms   ------------------------------------------------

  def _get_sounds(self):
    sounds_default  = os.path.join(os.path.expanduser("~"),"sounds")
    self._sound_dir = self._settings.get_value('SOUND','sounds',sounds_default)

    if not os.path.isdir(self._sound_dir):
      return []

    sounds = []
    for f in os.listdir(self._sound_dir):
      if not os.path.isfile(os.path.join(self._sound_dir,f)):
        continue
      else:
        sounds.append(f)
    sounds.sort()
    return sounds

  # --- get runnable alarm   -----------------------------------------------

  def get_alarm(self,nr,alarm):
    """ return runnable alarm """

    self._settings.log.msg("SoundController: creating alarm-thread for alarm %s" % nr)

    # query alarm-settings
    try:
      cfg = json.loads(self._settings.get("alarm.%s.sound" % nr))
    except:
      cfg = self._settings.get("alarm.%s.sound" % nr,deep=True)

    if not cfg.has_key('name') or not cfg['name']:
      return None

    # return alarm
    t = threading.Thread(target=self.play_sound,args=(alarm.event,),kwargs=cfg)
    return t

  # --- play a given sound   ------------------------------------------------

  def play_sound(self,stop_me,name=None,fadein=0,duration=10,volume=40):
    """ play a given sound for the given duration """

    if os.path.isabs(name):
      sound_file = name
    else:
      sound_file = os.path.join(self._sound_dir,name)

    if not os.path.isfile(sound_file):
      self._settings.log.msg("%s does not exist" % sound_file)
      return

    duration = int(duration)
    fadein   = float(fadein)
    volume   = str(volume)

    # calculate fadein-increment
    intval = 5                        # we increment every 5 seconds
    steps  = 60*duration/intval       # incrementation steps
    incvol = float(volume)/steps
    incvol = 1 if incvol < 1 else incvol      # amixer does not support fractions

    self._settings.log.msg("SoundController: playing %s for %s minutes" %
                           (sound_file,duration))

    start_time = time.time()
    end_time   = start_time + 60*duration
    now        = start_time
    if simulate:
      stop_me.wait(60*duration)
    else:
      with self._lock:
        # set volume
        if fadein == 0:
          self._settings.log.msg("SoundController: setting volume to %s%%" % volume)
          args = shlex.split("amixer -q set %s %s%%" % (self._mixer,volume))
        else:
          self._settings.log.msg(
            "SoundController: starting fadein from %g%%" % incvol)
          args = shlex.split("amixer -q set %s %g%%" % (self._mixer,incvol))
          volume = float(volume)
        subprocess.call(args)

        # start playing sound
        args = ['mpg123','-q','--loop','-1']
        if self._mpg123_opts:
          args += shlex.split(self._mpg123_opts)
        if sound_file.endswith(("m3u","M3U")):
          args += ['-@',sound_file]
        else:
          args.append(sound_file)

        self._settings.log.msg(
          "SoundController: starting mpg123 with arguments %s" % args)
        prog = subprocess.Popen(args)

        current_volume = 0
        i = 1
        while now <= end_time:
          if stop_me.wait(1.0):
            break
          if fadein > 0:
            # check and increment volume if necessary
            if current_volume < volume and i % intval == 0:
              current_volume += incvol
              self._settings.log.msg(
                "SoundController: setting volume to %g%%" % current_volume)
              args = shlex.split("amixer -q set %s %g%%" %
                                 (self._mixer,current_volume))
              subprocess.call(args)
            i = i + 1
          now = time.time()

        # stop playing sound
        try:
          os.kill(prog.pid, signal.SIGKILL)
          prog.wait()
        except:
          pass
    self._settings.log.msg("SoundController: end of music")
