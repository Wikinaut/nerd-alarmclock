#!/usr/bin/python
# --------------------------------------------------------------------------
# Class definition of SoundController - utility functions for sound output
# and playing internet-radio.
#
# Please edit /etc/nerd-alarmclock.conf to configure this thread
#
# Author: Bernhard Bablok
# License: GPL3
#
# Website: https://github.com/bablokb/nerd-alarmclock
#
# --------------------------------------------------------------------------

import os, signal, subprocess, shlex, time, threading, json, traceback

simulate=False

class SoundController(object):
  """ Utility functions for sound output """

  # initialize object   ----------------------------------------------------

  def __init__(self,settings):
    """ Constructor """
    self._settings    = settings
    self._stop_event  = settings.stop_event
    self._lock        = threading.Lock()
    self._mpg123_opts = settings.get_value('SOUND','mpg123_opts','')
    self._mixer       = settings.get_value('SOUND','mixer','PCM')
    self._radio_state = False

    settings.add_alarm_provider(self.get_alarm)
    settings.set("_sound_alarms",self._get_sounds())

    settings.add_settings_listener("_radio.state",self.on_state)
    settings.add_settings_listener("_radio.list",self.on_list)
    settings.add_settings_listener("_radio.channel",self.on_channel)
    settings.add_settings_listener("_radio.volume",self.on_volume)
    settings.add_settings_listener("_radio.show_channel",self.on_show_channel)
    self._radio_stop_event = None
    self._setup_channel_lists()

    # save current volume in settings
    volume = self._get_volume()
    settings.set("_radio.volume",volume,notify=False)

  # --- read available sounds   --------------------------------------------

  def _get_sounds(self):
    """ read available sounds """

    sounds_default  = os.path.join(os.path.expanduser("~"),"sounds")
    self._sound_dir = self._settings.get_value('SOUND','sounds',sounds_default)

    if not os.path.isdir(self._sound_dir):
      return []

    sounds = []
    for f in os.listdir(self._sound_dir):
      if not os.path.isfile(os.path.join(self._sound_dir,f)):
        continue
      else:
        sounds.append(f)
    sounds.sort()
    return sounds

  # --- read radio channel lists   -----------------------------------------

  def _setup_channel_lists(self):
    """ read channel lists """

    channels_default  = os.path.join(os.path.expanduser("~"),"channels")
    self._channels_dir = self._settings.get_value('RADIO','channels',
                                                  channels_default)

    self._settings.log.msg("SoundController: channels-dir: %s" %
                                                         self._channels_dir)
    if not os.path.isdir(self._channels_dir):
      self._settings.log.msg("SoundController: channels-dir does not exist")
      return []

    # every file is a list with channels, so read the lists first
    self._channel_lists   = []
    self._channels        = []
    self._current_list    = self._settings.get("radio.current.list")
    self._settings.log.msg("SoundController: current list: %r" % self._current_list)

    list_i = 0
    for f in os.listdir(self._channels_dir):
      channels_file = os.path.join(self._channels_dir,f)
      if not os.path.isfile(channels_file):
        continue
      else:
        # try to load the list
        try:
          self._settings.log.msg("SoundController: reading %s" % channels_file)
          fp = open(channels_file,"r")
          self._channels.append(json.load(fp))
          fp.close()
        except:
          self._settings.log.msg(traceback.format_exc())
          continue

        # append name to array of channels
        name = f.split('.',1)[0]
        self._channel_lists.append(name)

        # query current channel of given list
        index = self._settings.get("radio.channel.%s.index" % name)
        self._settings.log.msg("SoundController: current index for %s: %r" %
                               (name,index))
        if not index:
          index = 0
          self._settings.set("radio.channel.%s.index" % name,index,notify=False)

        if self._current_list == name:
          self._current_list_index = list_i
          self._current_index      = index

        list_i += 1

    # if current list is not yet set or doesn't exist anymore,
    # initialize it to first list
    if not self._current_list or not hasattr(self,"_current_list_index"):
      self._current_list       = self._channel_lists[0]
      self._current_list_index = 0
      self._current_index      = 0
      self._settings.set("radio.current.list",self._current_list,notify=False)
      self._settings.set("radio.channel.%s.index" % self._current_list,
                         self._current_list_index,notify=False)

    # write log
    self._settings.log.msg("SoundController: current list: %s" % self._current_list)
    self._settings.log.msg("SoundController: current index of list: %s" %
                           self._current_list_index)
    self._settings.log.msg("SoundController: current index of channel: %s" %
                           self._current_index)

    # set indices in settings
    self._settings.set("_radio.list",self._current_list_index,notify=False)
    self._settings.set("_radio.channel",self._current_index,notify=False)

  # --- get runnable alarm   -----------------------------------------------

  def get_alarm(self,nr,alarm):
    """ return runnable alarm """

    self._settings.log.msg("SoundController: creating alarm-thread for alarm %s" % nr)

    # query alarm-settings
    try:
      cfg = json.loads(self._settings.get("alarm.%s.sound" % nr))
    except:
      cfg = self._settings.get("alarm.%s.sound" % nr,deep=True)

    if not cfg.has_key('name') or not cfg['name']:
      return None

    # return alarm
    t = threading.Thread(target=self.play_sound,args=(alarm.event,),kwargs=cfg)
    return t

  # --- query volume-setting   ----------------------------------------------

  def _get_volume(self):
    """ query current setting of volume from the mixer """

    try:
      cmd = "amixer get %s|grep -o [0-9]*%%|sed 's/%%//'| head -n 1" % self._mixer
      cur_vol = subprocess.check_output(cmd,shell=True).splitlines()[0]
      self._settings.log.msg("current volume is: %s%%" % cur_vol)
      return cur_vol
    except:
      self._settings.log.msg(traceback.format_exc())
      return None

  # --- query volume-setting   ----------------------------------------------

  def _set_volume(self,volume):
    """ set volume """

    self._settings.log.msg("SoundController: setting volume to %s%%" % volume)
    try:
      args = shlex.split("amixer -q set %s %s%%" % (self._mixer,volume))
      subprocess.call(args)
    except:
      self._settings.log.msg(traceback.format_exc())

  # --- play a given sound   ------------------------------------------------

  def play_sound(self,stop_me,name=None,fadein=0,duration=10,volume=40):
    """ play a given sound for the given duration """

    if os.path.isabs(name):
      sound_file = name
    else:
      sound_file = os.path.join(self._sound_dir,name)

    if not os.path.isfile(sound_file):
      self._settings.log.msg("%s does not exist" % sound_file)
      return

    duration = int(duration)
    fadein   = float(fadein)
    volume   = str(volume)

    # calculate fadein-increment
    intval = 5                        # we increment every 5 seconds
    steps  = 60*duration/intval       # incrementation steps
    incvol = float(volume)/steps
    incvol = 1 if incvol < 1 else incvol      # amixer does not support fractions

    # save current volume
    old_vol = self._get_volume()

    self._settings.log.msg("SoundController: playing %s for %s minutes" %
                           (sound_file,duration))

    start_time = time.time()
    end_time   = start_time + 60*duration
    now        = start_time
    if simulate:
      stop_me.wait(60*duration)
    else:
      with self._lock:
        # set volume
        if fadein == 0:
          self._set_volume(volume)
        else:
          self._settings.log.msg(
            "SoundController: starting fadein from %g%%" % incvol)
          self._set_volume(incvol)
          volume = float(volume)

        # start playing sound
        args = ['mpg123','-q','--loop','-1']
        if self._mpg123_opts:
          args += shlex.split(self._mpg123_opts)
        if sound_file.endswith(("m3u","M3U")):
          args += ['-@',sound_file]
        else:
          args.append(sound_file)

        self._settings.log.msg(
          "SoundController: starting mpg123 with arguments %s" % args)
        prog = subprocess.Popen(args)

        current_volume = incvol
        i = 1
        while now <= end_time:
          if stop_me.wait(1.0):
            break
          if fadein > 0:
            # check and increment volume if necessary
            if current_volume < volume and i % intval == 0:
              current_volume += incvol
              self._set_volume(current_volume)
            i = i + 1
          now = time.time()

        # stop playing sound
        try:
          os.kill(prog.pid, signal.SIGKILL)
          prog.wait()
        except:
          pass

        # reset volume
        if not old_vol is None:
          if volume != old_vol or fadein > 0 and current_volume != old_vol:
            self._set_volume(old_vol)

    self._settings.log.msg("SoundController: end of music")

  # --- handler for state-change events   ------------------------------------

  def on_state(self,name,old,new):
    """ handle state change event """

    self._settings.log.msg("SoundController: changing radio state to %r" % new)
    self._radio_state = new
    self._set_radio_state(new)

  # --- handler for list-change events   ------------------------------------

  def on_list(self,name,old,new):
    """ handle channel-list change event """

    # ignore event if radio is off
    if not self._radio_state:
      self._settings.log.msg("SoundController: ignoring on_list (radio is off)")
      return

    # calculate new index using wrap-around if necessary
    num_lists = len(self._channel_lists)
    if new < 0:
      index = num_lists + new                            # new is negative!
    elif new > num_lists - 1:
      index = new - num_lists
    else:
      index = new
    self._settings.log.msg("SoundController: changing to channel list %d" % index)

    # update settings
    self._current_list_index = index
    name = self._channel_lists[index]
    self._settings.set("_display.text",name)
    self._current_index = self._settings.get("radio.channel.%s.index" % name)
    self._settings.set("_radio.list",index,notify=False)
    self._settings.set("_radio.channel",self._current_index)

  # --- handler for channel-change events   ---------------------------------

  def on_channel(self,name,old,new):
    """ handle channel change events """

    # ignore event if radio is off
    if not self._radio_state:
      self._settings.log.msg("SoundController: ignoring on_channel (radio is off)")
      return

    # calculate new index using wrap-around if necessary
    num_channels = len(self._channels[self._current_list_index])
    if new < 0:
      self._current_index = num_channels + new             # new is negative!
    elif new > num_channels - 1:
      self._current_index = new - num_channels
    else:
      self._current_index = new
    self._settings.log.msg("SoundController: changing to channel %d" %
                           self._current_index)

    # update settings
    self._settings.set("_radio.channel",self._current_index,notify=False)
    self._settings.set("radio.channel.%s.index" % self._current_list,
                       self._current_index,notify=False)

    # now stop the old channel ...
    self._set_radio_state(False)

    # ... and start the new one
    self._set_radio_state(True)

  # --- show channel   ------------------------------------------------------

  def on_show_channel(self,name,old,new):
    """ show name of channel """

    if new:
      channel = self._channels[self._current_list_index][self._current_index]
      self._settings.set("_display.text",channel['name'])

  # --- start/stop the radio   ----------------------------------------------

  def _set_radio_state(self,state):
    """ turn radio on or off """

    self._settings.log.msg("SoundController: setting radio state to %r" % state)
    if state:
      # turn radio on
      channel = self._channels[self._current_list_index][self._current_index]
      self._radio_stop_event = threading.Event()
      self._radio_thread     = threading.Thread(
                                target=self._play_channel,
                                args=(self._radio_stop_event,channel))
      self._radio_thread.start()
      self._settings.set("_display.text",channel['name'])
    else:
      # turn radio off
      if self._radio_stop_event:
        self._radio_stop_event.set()
        self._radio_thread.join()

  # --- play channel   ------------------------------------------------------

  def _play_channel(self,stop_me,channel):
    """ play given channel """

    name = channel['name']
    url  = channel['url']

    self._settings.log.msg("SoundController: starting channel %s" % name)
    if simulate:
      pass
    else:
      with self._lock:
        # start playing sound
        args = ['mpg123','-q']
        args.append(url)

        self._settings.log.msg(
          "SoundController: starting mpg123 with arguments %s" % args)
        prog = subprocess.Popen(args)

        while True:
          if self._stop_event.wait(0.1) or stop_me.wait(0.1):
            break

        # stop playing sound
        try:
          os.kill(prog.pid, signal.SIGKILL)
          prog.wait()
        except:
          pass
    self._settings.log.msg("SoundController: stopping channel %s" % name)

  # --- handler for volume-change events   ----------------------------------

  def on_volume(self,name,old,new):
    """ handle volume change events """

    self._settings.log.msg("SoundController: on_volume: old: %s, new: %s" %
                           (old,new))
    if int(new) < 0:
      self._settings.set("_radio.volume",0,notify=False)
    elif int(new) > 100:
      self._settings.set("_radio.volume",100,notify=False)
    else:
      self._set_volume(new)
