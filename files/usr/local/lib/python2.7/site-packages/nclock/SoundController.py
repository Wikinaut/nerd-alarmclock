#!/usr/bin/python
# --------------------------------------------------------------------------
# Class definition of SoundController - utility functions for sound output
# and playing internet-radio.
#
# Please edit /etc/nerd-alarmclock.conf to configure this thread
#
# Author: Bernhard Bablok
# License: GPL3
#
# Website: https://github.com/bablokb/nerd-alarmclock
#
# --------------------------------------------------------------------------

import os, signal, subprocess, shlex, time, threading, json, traceback

simulate=False

class SoundController(object):
  """ Utility functions for sound output """

  # initialize object   ----------------------------------------------------

  def __init__(self,settings):
    """ Constructor """
    self._settings    = settings
    self._lock        = threading.Lock()
    self._mpg123_opts = settings.get_value('SOUND','mpg123_opts','')
    self._mixer       = settings.get_value('SOUND','mixer','PCM')

    settings.add_alarm_provider(self.get_alarm)
    settings.set("_sound_alarms",self._get_sounds())

    self._setup_channel_lists()

  # --- read available sounds   --------------------------------------------

  def _get_sounds(self):
    """ read available sounds """

    sounds_default  = os.path.join(os.path.expanduser("~"),"sounds")
    self._sound_dir = self._settings.get_value('SOUND','sounds',sounds_default)

    if not os.path.isdir(self._sound_dir):
      return []

    sounds = []
    for f in os.listdir(self._sound_dir):
      if not os.path.isfile(os.path.join(self._sound_dir,f)):
        continue
      else:
        sounds.append(f)
    sounds.sort()
    return sounds

  # --- read radio channel lists   -----------------------------------------

  def _setup_channel_lists(self):
    """ read channel lists """

    channels_default  = os.path.join(os.path.expanduser("~"),"channels")
    self._channels_dir = self._settings.get_value('RADIO','channels',
                                                  channels_default)

    if not os.path.isdir(self._channels_dir):
      return []

    # every file is a list with channels, so read the lists first
    self._channel_lists   = []
    self._channels        = []
    self._current_list    = self._settings.get("radio.current.list")
    self._settings.log.msg("SoundController: current list: %r" % self._current_list)
    self._current_channel = []         # current index of every channel


    list_i = 0
    for f in os.listdir(self._channels_dir):
      channels_file = os.path.join(self._channels_dir,f)
      if not os.path.isfile(channels_file):
        continue
      else:
        # try to load the list
        try:
          self._settings.log.msg("SoundController: reading %s" % channels_file)
          fp = open(channels_file,"r")
          self._channels.append(json.load(fp))
          fp.close()
        except:
          self._settings.log.msg(traceback.format_exc())
          continue

        # append name to array of channels
        name = f.split('.',1)[0]
        self._channel_lists.append(name)
        if self._current_list == name:
          self._current_list_index = list_i

        # query current channel of given list
        index = self._settings.get("radio.channel.%s.index" % name)
        self._settings.log.msg("SoundController: current index for %s: %r" %
                               (name,index))
        if index:
          self._current_channel.append(index)
        else:
          self._current_channel.append(0)
          self._settings.set("radio.channel.%s.index" % name,0,notify=False)
        list_i += 1

    # if current list is not yet set, initialize it to first list
    if not self._current_list:
      self._current_list       = self._channel_lists[0]
      self._current_list_index = 0
      self._settings.set("radio.current.list",self._current_list,notify=False)
      self._settings.set("radio.channel.%s.index" % self._current_list,
                         self._current_list_index,notify=False)

  # --- get runnable alarm   -----------------------------------------------

  def get_alarm(self,nr,alarm):
    """ return runnable alarm """

    self._settings.log.msg("SoundController: creating alarm-thread for alarm %s" % nr)

    # query alarm-settings
    try:
      cfg = json.loads(self._settings.get("alarm.%s.sound" % nr))
    except:
      cfg = self._settings.get("alarm.%s.sound" % nr,deep=True)

    if not cfg.has_key('name') or not cfg['name']:
      return None

    # return alarm
    t = threading.Thread(target=self.play_sound,args=(alarm.event,),kwargs=cfg)
    return t

  # --- query volume-setting   ----------------------------------------------

  def _get_volume(self):
    """ query current setting of volume from the mixer """

    try:
      cmd = "amixer get %s|grep -o [0-9]*%%|sed 's/%%//'| head -n 1" % self._mixer
      cur_vol = subprocess.check_output(cmd,shell=True).splitlines()[0]
      self._settings.log.msg("current volume is: %s%%" % cur_vol)
      return cur_vol
    except:
      self._settings.log.msg(traceback.format_exc())
      return None

  # --- query volume-setting   ----------------------------------------------

  def _set_volume(self,volume):
    """ set volume """

    self._settings.log.msg("SoundController: setting volume to %s%%" % volume)
    try:
      args = shlex.split("amixer -q set %s %s%%" % (self._mixer,volume))
      subprocess.call(args)
    except:
      self._settings.log.msg(traceback.format_exc())

  # --- play a given sound   ------------------------------------------------

  def play_sound(self,stop_me,name=None,fadein=0,duration=10,volume=40):
    """ play a given sound for the given duration """

    if os.path.isabs(name):
      sound_file = name
    else:
      sound_file = os.path.join(self._sound_dir,name)

    if not os.path.isfile(sound_file):
      self._settings.log.msg("%s does not exist" % sound_file)
      return

    duration = int(duration)
    fadein   = float(fadein)
    volume   = str(volume)

    # calculate fadein-increment
    intval = 5                        # we increment every 5 seconds
    steps  = 60*duration/intval       # incrementation steps
    incvol = float(volume)/steps
    incvol = 1 if incvol < 1 else incvol      # amixer does not support fractions

    # save current volume
    old_vol = self._get_volume()

    self._settings.log.msg("SoundController: playing %s for %s minutes" %
                           (sound_file,duration))

    start_time = time.time()
    end_time   = start_time + 60*duration
    now        = start_time
    if simulate:
      stop_me.wait(60*duration)
    else:
      with self._lock:
        # set volume
        if fadein == 0:
          self._set_volume(volume)
        else:
          self._settings.log.msg(
            "SoundController: starting fadein from %g%%" % incvol)
          self._set_volume(incvol)
          volume = float(volume)

        # start playing sound
        args = ['mpg123','-q','--loop','-1']
        if self._mpg123_opts:
          args += shlex.split(self._mpg123_opts)
        if sound_file.endswith(("m3u","M3U")):
          args += ['-@',sound_file]
        else:
          args.append(sound_file)

        self._settings.log.msg(
          "SoundController: starting mpg123 with arguments %s" % args)
        prog = subprocess.Popen(args)

        current_volume = incvol
        i = 1
        while now <= end_time:
          if stop_me.wait(1.0):
            break
          if fadein > 0:
            # check and increment volume if necessary
            if current_volume < volume and i % intval == 0:
              current_volume += incvol
              self._set_volume(current_volume)
            i = i + 1
          now = time.time()

        # stop playing sound
        try:
          os.kill(prog.pid, signal.SIGKILL)
          prog.wait()
        except:
          pass

        # reset volume
        if not old_vol is None:
          if volume != old_vol or fadein > 0 and current_volume != old_vol:
            self._set_volume(old_vol)

    self._settings.log.msg("SoundController: end of music")
