#!/usr/bin/python
# --------------------------------------------------------------------------
# Class definition of DisplayController - utility functions for the
# segment display.
#
# Please edit /etc/nerd-alarmclock.conf to configure this thread
#
# Author: Bernhard Bablok
# License: GPL3
#
# Website: https://github.com/bablokb/nerd-alarmclock
#
# --------------------------------------------------------------------------

import time, threading, colorsys, json

simulate=False
try:
  import fourletterphat as display
except:
  # we assume our test-environment
  simulate=True

class DisplayController(object):
  """ Utility functions for the segment-display """

  BNESS  = [-1, 0, 1, 4, 15]     # usable brightness-values (0 is not off)

  # the four-letter pHat has four segments with four decimal points. So
  # we only support four alarms (regardless of the global count)
  MAX_ALARMS = 4

  # initialize object   ----------------------------------------------------

  def __init__(self,settings):
    """ Constructor """
    self._settings = settings
    self._lock     = threading.Lock()
    self._max_alarms = min(DisplayController.MAX_ALARMS,settings.MAX_ALARMS)

    # set display and brightness
    self._initialize()

    settings.add_settings_listener('_display.text',self.on_text)
    settings.add_settings_listener('_display.brightness',self.on_brightness)
    settings.add_settings_listener('display.brightness.day',self.on_brightness)
    settings.add_settings_listener('display.brightness.night',self.on_brightness)
    for nr in range(1,self._max_alarms+1):
      settings.add_settings_listener('alarm.%s.state' % nr,self.on_alarm_state)
    settings.add_settings_listener('_current_time',self.on_time)
    settings.add_settings_listener('_day_mode',self.on_day_mode)
    settings.add_settings_listener('_do_config',self.on_do_config)

    # add ourself as alarm-provider
    settings.add_alarm_provider(self.get_alarm)
    # save list of alarms in settings
    alarms = []
    for method in dir(self):
      if method.startswith("alarm_"):
        alarms.append(method[6:])
    settings.set("_display_alarms",alarms)

  # --- initialize the display (brightness, time)   ------------------------

  def _initialize(self):
    """ Initialize time and brightness """

    # query and initialize alarms
    self._alarms = []
    for i in range(self._max_alarms):
      state = self._settings.get("alarm."+str(i+1)+".state")
      self._alarms.append(state != "disabled")

    # initialize time-display (including alarm-indicator)
    self._current_time = time.strftime("%H:%M")
    self._brightness   = 2
    self._settings.set("_display.brightness",self._brightness)
    self.set_time()

  # --- time change listener   ---------------------------------------------

  def on_time(self,name,old,new):
    """ process time-change events (update time)"""
    self._current_time = new
    self._settings.log.msg("DisplayController: on_time(%s,%s)" % (old,new))
    self.set_time()

  # --- set the time   -----------------------------------------------------

  def set_time(self):
    """ show the current time on the display """

    self._exec_with_lock(self._set_time,())
    for i in range(self._max_alarms):
      self._exec_with_lock(self._set_decimal,(i,self._alarms[i]))

  # --- set the time   -----------------------------------------------------

  def _set_time(self):
    """ set the current time on the display """

    # should be called with _exec_with_lock
    self._settings.log.msg("DisplayController: setting time to: %s" %
                                                         self._current_time)
    display.clear()
    if self._brightness > 0:
      t_string = self._current_time.replace(":","")
      display.print_str(t_string)
    display.show()

  # --- day-mode change listener   -----------------------------------------

  def on_day_mode(self,name,old,new):
    """ process day-mode-changes """

    value = self._settings.get("display.brightness."+new)
    self.set_brightness(value)

  # --- brightness change listener   ---------------------------------------

  def on_brightness(self,name,old,new):
    """ process brightness-changes """

    if old == new:
      return
    self._settings.log.msg("DisplayController: on_brightness(%s,%s)" % (old,new))
    self.set_brightness(new)
    if old == 0:
      # turn on display again (i.e. show time)
      self.set_time()

  # --- set the brightness of the display   --------------------------------

  def set_brightness(self,value=None):
    """ Set the brightness of the display """
    # we only use off and four levels, so scale new appropriately
    if not value is None and value != self._brightness:
      self._brightness = value
      self._settings.set("_display.brightness",self._brightness)
    self._settings.log.msg("DisplayController: setting brightness to: %d" % self._brightness)
    if not simulate:
      # can't set brightness during an alarm
      if self._lock.acquire(False):
        if self._brightness > 0:
          display.set_brightness(DisplayController.BNESS[self._brightness])
        else:
          display.clear()
        display.show()
        self._lock.release()

  # --- alarm change listener   -------------------------------------------

  def on_alarm_state(self,name,old,new):
    """ process alarm changes: set or unset decimal """

    nr = int(name[6])
    self._settings.log.msg("DisplayController: changing state of alarm %d from %s to %s" %
                           (nr,old,new))
    state = new != "disabled"
    index = nr-1
    self._alarms[index] = state      # keep state, so set_time works

    if old == "disabled":
      # show configured alarm-time when turning alarm on
      text = self._settings.get("alarm.%s.time" % nr ).replace(":","")
      self._exec_with_lock(self.show_text,(text,1,True))
      self.set_time()
    else:
      # just update decimal
      self._exec_with_lock(self._set_decimal,(index,state))

  # --- on_text listener   -------------------------------------------------

  def on_text(self,name,old,new):
    """ display text for given time """

    self._settings.log.msg("DisplayController: set text to %s" % new)
    self._exec_with_lock(self.show_text,(new,4,False))
    self.set_time()

  # --- do_config listener   -----------------------------------------------

  def on_do_config(self,name,old,new):
    """ change blink-mode of display during configuration """

    self._settings.log.msg("DisplayController: set blink mode to %s" % new)
    self._exec_with_lock(self._set_blink,(new == "on",))

  # --- set blink state   --------------------------------------------------

  def _set_blink(self,state):
    """ set blink state """

    # should be called with _exec_with_lock
    if state:
      display.set_blink(display.HT16K33_BLINK_1HZ)
    else:
      display.set_blink(display.HT16K33_BLINK_OFF)

  # --- display a text for the given time   --------------------------------

  def show_text(self,text,duration=2,blink=True):
    """ show text for the given time """

    # should be called with _exec_with_lock
    self._settings.log.msg("DisplayController: showing text: %s" % text)
    if self._brightness == 0:
      time.sleep(duration)
      return
    display.clear()

    # scroll long text
    if len(text) > 4:
      steps = len(text) - 3
      sleep_time = float(duration)/steps
      for i in range(steps):
        display.print_str(text[:4],False)
        display.show()
        time.sleep(sleep_time)
        text = text[1:]
    else:
      display.print_str(text,False)
      if blink:
        display.set_blink(display.HT16K33_BLINK_2HZ)
      display.show()
      time.sleep(duration)
      if blink:
        display.set_blink(display.HT16K33_BLINK_OFF)

  # --- set decimal   ------------------------------------------------------

  def _set_decimal(self,index,state):
    """ set decimal at given index """

    # should be called with _exec_with_lock
    if self._brightness > 0:
      display.set_decimal(index,state)
      display.show()
    
  # --- execute a function with lock   -------------------------------------

  def _exec_with_lock(self,func,args):
    if not simulate:
      # some other method might be blocking the display. This could either
      # be short-term (e.g. set-time) or long-term (alarm)
      # so we check twice
      if self._lock.acquire(False):
        func(*args)
        self._lock.release()
      else:
        # try short-term
        time.sleep(0.5)
        if self._lock.acquire(False):
          func(*args)
          self._lock.release()
        else:
          # give up (we expect to be called again, e.g. after the alarm)
          pass

  # --- get runnable alarm   -----------------------------------------------

  def get_alarm(self,nr,alarm):
    """ return runnable alarm """

    self._settings.log.msg("DisplayController: creating alarm-thread for alarm %s" % nr)

    # query alarm-settings
    try:
      cfg = json.loads(self._settings.get("alarm.%s.display" % nr))
    except:
      cfg = self._settings.get("alarm.%s.display" % nr,deep=True)

    if not cfg.has_key('name') or not cfg['name']:
      return None

    if not hasattr(self,"alarm_"+cfg['name']):
      self._settings.log.msg("DisplayController: unsupported alarm: %s" % cfg['name'])
      return None
      
    alarm_func=getattr(self,"alarm_"+cfg['name'])
    del cfg['name']

    # return alarm
    t = threading.Thread(target=alarm_func,args=(alarm.event,),kwargs=cfg)
    return t

  # --- alarm with running text   ------------------------------------------

  def alarm_text(self,stop_me,duration=1,text=None,delay=0):
    if not text:
      return
    duration = int(duration)

    self._settings.log.msg(
      "DisplayController: show alarm text '%s' for %s minutes" % (text,duration))

    # honor delay
    delay = int(delay)
    if delay > 0:
      self._settings.log.msg(
        "DisplayController: delaying alarm for %d minutes" % delay)
      if stop_me.wait(60*delay):
        return

    if simulate:
      stop_me.wait(60*duration)
      self._settings.log.msg("DisplayController: show alarm text finished")
      return

    start_time = time.time()
    end_time   = start_time + 60*duration
    now        = start_time

    with self._lock:
      display.clear()
      display.set_brightness(15)
      while now <= end_time:
        display.print_str(text[:4])
        display.show()
        if stop_me.wait(0.35):
          break
        text = text[1:] + text[0]
        now = time.time()

    # reset display to standard
    self._settings.log.msg("DisplayController: show alarm text finished")
    self.set_time()
    self.set_brightness()

  # --- alarm with running text   ------------------------------------------

  def alarm_daydatetime(self,stop_me,duration=1,delay=0):
    duration = int(duration)
    self._settings.log.msg("DisplayController: show day-date-time as alarm-text")

    # query datetime-text and replace some values
    text = time.strftime("%a %x %H-%M   ")
    text = text.replace('.','-')

    # call generic alarm_text
    self.alarm_text(stop_me,duration=duration,text=text,delay=delay)
