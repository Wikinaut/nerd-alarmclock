#!/usr/bin/python
# --------------------------------------------------------------------------
# Class definition of DisplayController - utility functions for the
# segment display.
#
# Please edit /etc/nerd-alarmclock.conf to configure this thread
#
# Author: Bernhard Bablok
# License: GPL3
#
# Website: https://github.com/bablokb/nerd-alarmclock
#
# --------------------------------------------------------------------------

import time, threading, colorsys, json

simulate=False
try:
  import fourletterphat as display
except:
  # we assume our test-environment
  simulate=True

class DisplayController(object):
  """ Utility functions for the segment-display """

  # initialize object   ----------------------------------------------------

  def __init__(self,settings):
    """ Constructor """
    self._settings = settings
    self._lock     = threading.Lock()

    # set display and brightness
    self._initialize()

    settings.add_settings_listener('display.brightness.day',self.on_brightness)
    settings.add_settings_listener('display.brightness.night',self.on_brightness)
    settings.add_settings_listener('alarm.1.state',self.on_alarm_state)
    settings.add_settings_listener('alarm.2.state',self.on_alarm_state)
    settings.add_settings_listener('alarm.3.state',self.on_alarm_state)
    settings.add_settings_listener('alarm.4.state',self.on_alarm_state)
    settings.add_settings_listener('_current_time',self.on_time)
    settings.add_settings_listener('_day_mode',self.on_day_mode)
    settings.add_settings_listener('_do_config',self.on_do_config)

    # add ourself as alarm-provider
    settings.add_alarm_provider(self.get_alarm)
    # save list of alarms in settings
    alarms = []
    for method in dir(self):
      if method.startswith("alarm_"):
        alarms.append(method[6:])
    settings.set("_display_alarms",alarms)

  # --- initialize the display (brightness, time)   ------------------------

  def _initialize(self):
    """ Initialize time and brightness """

    # query and initialize alarms
    self._alarms = []
    for i in range(self._settings.MAX_ALARMS):
      state = self._settings.get("alarm."+str(i+1)+".state")
      self._alarms.append(state != "disabled")

    # initialize time-display (including alarm-indicator)
    self._current_time = time.strftime("%H:%M")
    self.set_time()

  # --- execute a function with lock   -------------------------------------

  def _exec_with_lock(self,func,args):
    if not simulate:
      # some other method might be blocking the display. This could either
      # be short-term (e.g. set-time) or long-term (alarm)
      # so we check twice
      if self._lock.acquire(False):
        func(**args)
        self._lock.release()
      else:
        # try short-term
        time.sleep(0.5)
        if self._lock.acquire(False):
          func(**args)
          self._lock.release()
        else:
          # give up (we expect to be called again, e.g. after the alarm)
          pass

  # --- set the time   -----------------------------------------------------

  def set_time(self):
    """ show the current time on the display """

    self._exec_with_lock(self._set_time,(,))
    for i in range(self._settings.MAX_ALARMS):
      self._exec_with_lock(self._set_decimal,(i,self._alarms[i]))

  # --- set the brightness of the display   --------------------------------

  def set_brightness(self,value=None):
    """ Set the brightness of the display """
    # we only use off and four levels, so scale new appropriately
    if not value is None:
      self._brightness = value
    self._settings.log.msg("Display: Setting brightness to: %d" % self._brightness)
    if not simulate:
      # can't set brightness during an alarm
      if self._lock.acquire(False):
        display.set_brightness(min(4*value,15))
        display.show()
        self._lock.release()

  # --- time change listener   ---------------------------------------------

  def on_time(self,name,old,new):
    """ process time-change events (update time)"""
    self._current_time = new
    self._settings.log.msg("DisplayController.on_time(%s,%s)" % (old,new))
    self.set_time()

  # --- day-mode change listener   -----------------------------------------

  def on_day_mode(self,name,old,new):
    """ process day-mode-changes """

    value = self._settings.get("display.brightness."+new)
    self.set_brightness(value)

  # --- brightness change listener   ---------------------------------------

  def on_brightness(self,name,old,new):
    """ process brightness-changes """

    self._settings.log.msg("DisplayController.on_brightness(%s,%s)" % (old,new))
    self.set_brightness(new)

  # --- alarm change listener   -------------------------------------------

  def on_alarm_state(self,name,old,new):
    """ process alarm changes: set or unset decimal """

    nr = int(name[6])
    self._settings.log.msg("Changing state of alarm %d from %s to %s" %
                           (nr,old,new))
    state = new != "disabled"
    index = nr-1
    self._alarms[index] = state      # keep state, so set_time works
    self._exec_with_lock(self._set_decimal,(index,state))

  # --- do_config listener   -----------------------------------------------

  def on_do_config(self,name,old,new):
    """ change blink-mode of display during configuration """

    self._settings.log.msg("Display: set blink mode to %s" % new)
    if not simulate:
      with self._lock:
        if new == "on":
          display.set_blink(display.HT16K33_BLINK_1HZ)
        else:
          display.set_blink(display.HT16K33_BLINK_OFF)

  # --- set the time   -----------------------------------------------------

  def _set_time(self):
    """ set the current time on the display """

    # should be called with _exec_with_lock
    t_string = self._current_time[0:2] + self._current_time[3:5]

    self._settings.log.msg("Setting time to: %s" % self._current_time)
    display.clear()
    display.print_str(t_string)
    display.show()

  # --- set decimal   ------------------------------------------------------

  def _set_decimal(self,index,state):
    """ set decimal at given index """

    # should be called with _exec_with_lock
    display.set_decimal(index,state)
    display.show()
    
  # --- get runnable alarm   -----------------------------------------------

  def get_alarm(self,nr,alarm):
    """ return runnable alarm """

    self._settings.log.msg("Display: creating alarm-thread for alarm %s" % nr)

    # query alarm-settings
    try:
      cfg = json.loads(self._settings.get("alarm.%s.display" % nr))
    except:
      cfg = self._settings.get("alarm.%s.display" % nr,deep=True)

    if not cfg.has_key('name') or not cfg['name']:
      return None

    alarm_func=getattr(self,"alarm_"+cfg['name'])
    del cfg['name']

    # return alarm
    t = threading.Thread(target=alarm_func,args=(alarm.event,),kwargs=cfg)
    return t

  # --- alarm with running text   ------------------------------------------

  def alarm_text(self,stop_me,duration=1,text=None):
    if not text:
      return
    duration = int(duration)

    self._settings.log.msg(
      "Display: show alarm text %s for %s minutes" % (text,duration)
)
    if simulate:
      stop_me.wait(60*duration)
      return

    start_time = time.time()
    end_time   = start_time + 60*duration
    now        = start_time

    with self._lock:
      display.clear()
      display.set_brightness(15)
      while now <= end_time:
        display.print_str(text[:4])
        display.show()
        if stop_me.wait(0.35):
          break
        text = text[1:] + text[0]
        now = time.time()

    # reset display to standard
    self.set_time()
    self.set_brightness()

  # --- alarm with running text   ------------------------------------------

  def alarm_daydatetime(self,stop_me,duration=1):
    duration = int(duration)
    self._settings.log.msg("Display: show day-date-time as alarm-text")
    text = time.strftime("%a %x %X")
    self.alarm_text(stop_me,duration=duration,text=text)
