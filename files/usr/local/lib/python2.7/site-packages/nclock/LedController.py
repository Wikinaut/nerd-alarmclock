#!/usr/bin/python
# --------------------------------------------------------------------------
# Class definition of LedController - utility functions for the LED-strip
#
# This class also takes care of updating the LEDs during idle time
# (e.g. for clock-simulation)
#
# Please edit /etc/nerd-alarmclock.conf to configure this thread
#
# Author: Bernhard Bablok
# License: GPL3
#
# Website: https://github.com/bablokb/nerd-alarmclock
#
# --------------------------------------------------------------------------

import time, threading, colorsys

try:
  import blinkt
  simulate=False
except:
  # we assume our test-environment
  simulate=True

class LedController(object):
  """ Utility functions for the LED-strip """

  RED    = (255,0,0)
  YELLOW = (255,255,0)
  GREEN  = (0,255,0)
  BLUE   = (0,0,255)
  COLORS = [RED,YELLOW,GREEN,BLUE]

  # initialize object   ----------------------------------------------------

  def __init__(self,settings):
    """ Constructor """
    self._settings = settings
    self._lock     = threading.Lock()

    # set time and brightness
    self._initialize()

    settings.add_settings_listener('led.brightness.day',self.on_brightness)
    settings.add_settings_listener('led.brightness.night',self.on_brightness)
    settings.add_timechange_listener(self.on_time)
    settings.add_alarm_provider(self.get_alarm)
    
  # --- initialize the LEDs (brightness, time)   ----------------------------

  def _initialize(self):
    """ Initialize time and brightness """

    self._day_of_month = time.localtime().tm_mday
    self._set_day_of_month()
    self._set_brightness(self._get_brightness(time.strftime("%H:%M")))

  # --- get brightness   ---------------------------------------------------

  def _get_brightness(self,current_time):
    day_start = self._settings.get("day.start")
    day_end   = self._settings.get("day.end")

    if day_start <= current_time and current_time <= day_end:
      return self._settings.get("led.brightness.day")
    else:
      return self._settings.get("led.brightness.night")

  # --- set the day of month   ---------------------------------------------

  def _set_day_of_month(self):
    """ show the given day of month on the led """

    self._settings.log.msg("Setting day of month to: %d" % self._day_of_month)
    if not simulate:
      num_leds  = (self._day_of_month - 1) % 8 + 1
      col_index = (self._day_of_month - 1) // 8
      color = LedController.COLORS[col_index]
      with self._lock:
        for i in range(num_leds):
          blinkt.set_pixel(i,color[0],color[1],color[2])
          blinkt.show()

  # --- set the brightness of the LEDs   -----------------------------------

  def _set_brightness(self,value):
    """ Set the brightness of the leds """
    # we only use off and four levels, so scale new appropriately
    self._settings.log.msg("Setting brightness to: %d" % value)
    self._brightness = 0.25*value
    if not simulate:
      with self._lock:
        blinkt.set_brightness(0.25*value)
        blinkt.show()

  # --- time change listener   ---------------------------------------------

  def on_time(self,old,new):
    """ process time-change events (e.g. change LEDs)"""

    self._settings.log.msg("LedController.on_time(%s,%s)" % (old,new))

    # set day-of-month
    dom_now = int(new[0].split(':')[2])
    if dom_now != self._day_of_month:
      self._day_of_month = dom_now
      self._set_day_of_month()

    # update brightness (todo)
    pass

  # --- brightness change listener   ---------------------------------------

  def on_brightness(self,old,new):
    """ process brightness-changes """

    self._settings.log.msg("LedController.on_brightness(%s,%s)" % (old,new))
    self._set_brightness(new)

  # --- get runnable alarm   -----------------------------------------------

  def get_alarm(self,nr,alarm):
    """ return runnable alarm """

    self._settings.log.msg("creating alarm-thread for alarm %s" % nr)

    # return alarm (TODO: implement selection from settings)
    t = threading.Thread(target=self.police,args=(alarm.event,1))
    return t

  # sunrise simulation   ---------------------------------------------------

  def sunrise(self,duration,stop_me,stay_on=False):
    """ sunrise simulation for the light-alarm """

    # hue is in degrees
    HUE_START = 0                         # red
    HUE_END   = 50                        # yellow
    L_START   = 0.2

    delta   = 1.0/(duration*60)           # fraction per second
    H_delta = (HUE_END - HUE_START)*delta
    L_delta = (1.0-L_START)*delta

    # iterate from led-brightness low->high, hue start->end,
    #         saturation high->low, lightness low->high

    H          = HUE_START
    brightness = delta
    S          = 1.0
    L          = L_START

    sec = 0
    with self._lock:
      while sec <= duration*60:
        # wait one second and bail out if stopped
        if stop_me.wait(1):
          blinkt.clear()
          blinkt.show()
          return

        # convert HSL to RGB ...
        (R,G,B) = colorsys.hls_to_rgb(H/360.0,L,S)
        R = 255*R
        G = 255*G
        B = 255*B

        # ... and show
        blinkt.set_all(R,G,B,brightness)
        blinkt.show()

        # update values
        sec        = sec + 1
        brightness = brightness + delta
        H          = H + H_delta
        L          = L + L_delta

      # turn of LEDs
      if not repeat:
        blinkt.clear()
        blinkt.show()

  # police signal   --------------------------------------------------------

  def police(self,stop_me,duration):
    """ simulate police signal (modified from blinkt-example larson.py) """
    
    self._settings.log.msg("running LED-alarm 'police' for %d minutes" % duration)

    VALUES = [0, 0, 0, 0, 0, 16, 64, 255, 64, 16, 0, 0, 0, 0, 0, 0]

    start_time = time.time()
    end_time   = start_time + 60*duration
    now        = start_time

    if simulate:
      stop_me.wait(60*duration)
    else:
      with self._lock:
        while now <= end_time:

          delta  = (now - start_time) * 16
          offset = int(abs((delta % 16) - 8))

          for i in range(8):
            blinkt.set_pixel(i,0,0,VALUES[offset + i])

          blinkt.show()
          if stop_me.wait(0.1):
            blinkt.clear()
            blinkt.show()
            return
          now = time.time()
