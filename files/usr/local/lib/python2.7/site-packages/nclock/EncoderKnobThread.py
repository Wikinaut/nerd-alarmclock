#!/usr/bin/python
# --------------------------------------------------------------------------
# Class definition of EncoderKnobThread - this thread handles turns of
# the encoder-knobs
#
# Author: Bernhard Bablok
# License: GPL3
#
# Website: https://github.com/bablokb/nerd-alarmclock
#
# --------------------------------------------------------------------------

import time, select, os
from threading import Thread

from KeyController import KeyController

class EncoderKnobThread(Thread,KeyController):
  """ EncoderKnob thread """

  # constants   ------------------------------------------------------------

  POLL_INTERVAL  = 15000        # micro-seconds

  # initialize object   ----------------------------------------------------

  def __init__(self,id,settings):
    """ Constructor """

    self._id   = id
    self._name = "EncoderKnobThread(%d)" % id 
    super(EncoderKnobThread,self).__init__(name=self._name)
    self.init(settings)

    self._clock = self._settings.get_value('GPIO','EK%d_CLK' % id, None)
    self._data  = self._settings.get_value('GPIO','EK%d_DT' % id,  None)

    # callback-map: (id,value data-pin) -> callback
    self._map = { (1,0): self.radio_next_channel,
                  (1,1): self.radio_prev_channel,
                  (2,0): self.radio_volume_up,
                  (2,1): self.radio_volume_up
                }

  # write value to path   --------------------------------------------------
  

  def _write_value(self,path,value):
    """ write a value to the given path """

    fd = open(path,'w')
    fd.write(value)
    fd.close()
    return

  # setup and configure clock-pin interrupt   -----------------------------

  def _configure(self):
    """ setup clock and data pin """

    gpio_root = '/sys/class/gpio/'

    # check permissions (not available in test environment)
    if not os.access(gpio_root + 'export',os.W_OK):
      return None

    # setup data pin
    gpio_dir = gpio_root + 'gpio' + self._data + '/'
    if not os.path.isdir(gpio_dir):
      self._write_value(gpio_root + 'export', self._data)
    self._write_value(gpio_dir  + 'direction', 'in')
    self._fd_data  = open(gpio_dir + 'value', 'r').fileno()

    # setup clock pin
    gpio_dir = gpio_root + 'gpio' + self._clock + '/'
    if not os.path.isdir(gpio_dir):
      self._write_value(gpio_root + 'export', self._clock)
    self._write_value(gpio_dir  + 'direction', 'in')
    self._write_value(gpio_dir  + 'edge', 'falling')
    self._fd_clock  = open(gpio_dir + 'value', 'r')
    
    # ignore initial interrupt
    self._fd_clock.seek(0)
    self._fd_clock.read(1)

    poll_obj = select.poll()
    poll_obj.register(self._fd_clock,select.POLLPRI)
    return poll_obj

  # run the thread   -------------------------------------------------------

  def run(self):
    """ run-method of thread """

    msg_header = "%s: " % self._name
    if not self._clock or not self._data:
      self._settings.log.msg(msg_header + "no support for encoder knobs")
      return
    else:
      self._settings.log.msg(msg_header + "running thread")

    # configure and setup interrupt on clock-pin
    poll_obj = self._configure()

    if not poll_obj:
      self._settings.log.msg(msg_header + "could not setup pins")
      self._settings.log.msg(msg_header + "terminating thread")
      return

    # main loop
    while True:
      poll_result = poll_obj.poll(EncoderKnobThread.POLL_INTERVAL)
      for (fd,event) in poll_result:

        # do some sanity checks
        if event & select.POLLIN == select.POLLIN:
          self._settings.log.msg(msg_header +
                                 "event POLLIN not expected. Reading anyhow")
        elif event & select.POLLPRI != select.POLLPRI:
          self._settings.log.msg(msg_header +
                                 "event not POLLIN/POLLPRI. Ignoring event")
          continue

        # read current state of GPIO
        os.lseek(fd,0,os.SEEK_SET)
        state = int(os.read(fd,1))

        # check for invalid value (this does happen)
        if state == 1:
          self._settings.log.msg(msg_header + "invalid state 1. Ignoring")
          continue

        # now read data-pin and execute callback
        os.lseek(self._fd_data,0,os.SEEK_SET)
        data = int(os.read(self._fd_data,1))
        func = self._map[(self._id,data)]
        func("unused")

      # check for global stop
      if self._stop_event.wait(0.01):
        break

    poll_obj.unregister(self._fd_clock)
    self._settings.log.msg(msg_header + "terminating thread")

