#!/usr/bin/python
# --------------------------------------------------------------------------
# Class definition of LircThread - this thread handles IR-remote events.
#
# Author: Bernhard Bablok
# License: GPL3
#
# Website: https://github.com/bablokb/nerd-alarmclock
#
# --------------------------------------------------------------------------

import time, select, os, socket
from threading import Thread

from KeyController import KeyController

class LircThread(Thread,KeyController):
  """ Lirc thread """

  # constants   ------------------------------------------------------------

  POLL_INTERVAL  = 15
  LIRC_SOCKET = "/var/run/lirc/lircd"

  # initialize object   ----------------------------------------------------

  def __init__(self,settings):
    """ Constructor """
    
    super(LircThread,self).__init__(name="LircThread")
    self.init(settings)
    self._create_map()

    # state of keys processed
    self._long     = 0
    self._last_ts  = -1
    self._last_key = None

  # build the mapping tabe (name to function)   ----------------------------

  def _create_map(self):
    """ build the mapping table """

    self._key_map = {}
    for (btn,key) in self._settings.get_values('LIRC'):
      if btn == 'active':
        continue
      words = key.split()
      words.extend([0,0])
      [key_name,key_repeat,key_delay] = words[:3]
      self._settings.log.msg("LircThread: key for %s: %s" % (btn,key_name))
      self._key_map[key_name] = (btn,key_repeat,key_delay)

  # run the thread   -------------------------------------------------------

  def run(self):
    """ run-method of thread """
    self._settings.log.msg("LircThread: running LircThread")

    # wait for socket
    socket_wait = 0.5
    while not os.path.exists(LircThread.LIRC_SOCKET):
      if socket_wait < LircThread.POLL_INTERVAL/2:
        socket_wait *= 2
      self._settings.log.msg("LircThread: waiting for socket")
      if self._stop_event.wait(socket_wait):
        self._settings.log.msg("LircThread: terminating LircThread")
        return

    # make sure the open call does not block
    lirc_socket = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
    lirc_socket.connect(LircThread.LIRC_SOCKET)
    p_fd = lirc_socket.fileno()
    
    lirc_file = lirc_socket.makefile('r')
    poll_obj = select.poll()
    poll_obj.register(p_fd,select.POLLPRI|select.POLLIN)

    while True:
      self._settings.log.msg("LircThread: polling %s" % LircThread.LIRC_SOCKET)
      poll_result = poll_obj.poll(LircThread.POLL_INTERVAL*1000)
      for (fd,event) in poll_result:
        #self._settings.log.msg("LircThread: processing poll-event: %d" % event)

        # do some sanity checks
        if event & select.POLLHUP == select.POLLHUP:
          self._settings.log.msg("LircThread: POLLHUP received")
          # we just wait and hope the LIRC comes back
          if self._stop_event.wait(LircThread.POLL_INTERVAL):
            break
          continue

        line = lirc_file.readline()
        self._process_event(line)
      if self._stop_event.wait(0.01):
        break

    poll_obj.unregister(lirc_socket)
    lirc_file.close()
    lirc_socket.close()
    self._settings.log.msg("LircThread: terminating LircThread")

  # --- process events (multiplex)   ---------------------------------------

  def _process_event(self,event):
    ts = time.time()
    self._settings.log.msg("LircThread: processing event: %s" % event)

    [_hex,rep_count,key_name,_irname] = event.split(" ")
    rep_count = int(rep_count,16)

    # check for valid KEY (should not happen)
    if not self._key_map.has_key(key_name):
      self._settings.log.msg("LircThread: invalid KEY-nr: %s" % key_name)
      return

    (btn,key_repeat,key_delay) = self._key_map[key_name]
    key_repeat = int(key_repeat)
    key_delay  = int(key_delay)

    # check repeat and delay count (only relevant for positive rep_count)
    if rep_count > 0:
      if key_delay > 0 and key_delay <= rep_count:
        return
      # check repeat
      if key_repeat == 0:
        #ignore event
        return
      else:
        # ignore all but every nth event
        if rep_count % key_repeat > 0:
          return

    # check for LONG-modifier
    if btn == 'LONG':
      self._long = 1 - self._long    # toggle 1 and 0
      self._settings.log.msg("LircThread: long modifier set to %d" % self._long)
      return

    # map info to method and execute
    if self.METHODS[self._long].has_key((btn,self._state)):
      func = self.METHODS[self._long][(btn,self._state)]
      func(btn)
    else:
      self._settings.log.msg("LircThread: no method defined for (%s,%s)" %
                             (btn,self._state))

    # reset LONG-modifier
    self._long = 0
